{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#prettypyplot","title":"prettypyplot","text":"<p>The documentation including an gallery can be found here.</p> <p>This is a wrapper package for matplotlib to achieve more easily pretty figures. If you are looking for something complete, this project is nothing for you but maybe seaborn. The main aspect of this project is to help me syncing my rcParams files and to stop copy-pasting so much code.</p> <p>The aim of this project is to simplify the generation of some simple pre-defined figures. Almost all code is inspired or taken from the matplotlib gallery. If you are a power user or interested in generating complex figures, this packages is not ment for you and you should better take a look in the matplotlib gallery directly.</p> <p>This project is in an alpha stage, hence it is neither stable nor ready for production.</p> <p>CAUTION: Starting from version 1.0.0 (which is far in the future) API-breaking changes will be made only in major releases. Until then, it can be changed in every minor release (see changelog).</p>"},{"location":"#features","title":"Features","text":"<p>The most notable features are:</p> <ul> <li>Tested with matplotlib <code>3.3</code>-<code>3.10</code></li> <li>figsize specifies size of canvas. So labels, ticks or colorbars are not counted.</li> <li>Nice top-aligned outter legends</li> <li>New colors</li> </ul>"},{"location":"#usage","title":"Usage","text":"<p>This package uses an syntax very close to matplotlib. Hence, it should be straight forward to use it. Instead of calling a function on the axes itself, one needs to pass here the axes as an argument (args or kwargs).</p>"},{"location":"#installation","title":"Installation","text":"<p><pre><code>python3 -m pip install --upgrade prettypyplot\n</code></pre> or <pre><code>conda install -c conda-forge prettypyplot\n</code></pre> or for the latest dev version <pre><code>python3 -m pip install git+https://github.com/braniii/prettypyplot.git\n</code></pre></p>"},{"location":"#usage_1","title":"Usage","text":"<pre><code>import matplotlib.pyplot as plt\nimport prettypyplot as pplt\n\npplt.use_style()\nfig, ax = plt.subplots()\n...\npplt.plot(ax=ax, x, y)\npplt.savefig(output)\n</code></pre>"},{"location":"#known-bugs","title":"Known Bugs","text":"<ul> <li><code>plt.subplots_adjust()</code> does not work with <code>pplt.savefig(use_canvas_size=True)</code> If you find one, please open an issue.</li> <li><code>pplt.savefig(use_canvas_size=True)</code> is not compatible with a grid of subplots</li> </ul>"},{"location":"#known-workarounds","title":"Known Workarounds","text":"<p>The method <code>pyplot.subplots_adjust()</code> is not compatible with the option <code>use_canvas_size</code> in <code>prettypyplot.plot.savefig</code>, use instead: <pre><code># this doesn't work, use instead gridspec\nfig.subplots_adjust(hspace=0)\n# use this instead\nfig, axs = plt.subplots(..., gridspec_kw={'hspace': 0.000})\n</code></pre></p>"},{"location":"#comparison-to-matplotlib","title":"Comparison to <code>matplotlib</code>","text":"<code>matplotlib.pyplot.plot</code> <code>prettypyplot.plot</code> <code>matplotlib.pyplot.legend</code> <code>prettypyplot.legend</code> <code>matplotlib.pyplot.imshow</code> <code>prettypyplot.imshow</code> <code>matplotlib.pyplot.colorbar</code> <code>prettypyplot.colorbar</code>"},{"location":"#roadmap","title":"Roadmap:","text":"<p>The following list is sorted from near future to hopefully ever.</p> <ul> <li> add pytest</li> <li> add search functionality in doc</li> <li> refactoring code to improve readabilty</li> <li> add package to conda_forge</li> <li> add gallery page</li> <li> improve <code>plt.suplots()</code> behaviour together with <code>pplt.savefig()</code></li> <li> add more colorpalettes</li> <li> add countour line plot</li> <li> add axes_grid examples</li> <li> setup widths and scaling factors for beamer and poster mode</li> <li> tweak all function to enable <code>STYLE='minimal'</code></li> <li> implement tufte style</li> </ul>"},{"location":"#building-documentation","title":"Building Documentation:","text":"<p>The doc is based on mkdocs and can be created by <pre><code># installing all dependencies\npython -m pip install -e .[docs]\n\n# serve interactively\npython -m mkdocs serve\n</code></pre></p>"},{"location":"#similar-projects","title":"Similar Projects","text":"<ul> <li>seaborn</li> </ul>"},{"location":"#citing-prettypyplot","title":"Citing Prettypyplot","text":"<p>If you want to cite prettypyplot in scientific work please use:</p> <p>Prettypyplot: publication ready matplotlib figures made simple D. Nagel, 2022. Zenodo: 10.5281/zenodo.7278312</p>"},{"location":"#credits","title":"Credits:","text":"<p>In alphabetical order:</p> <ul> <li>colorcyclepicker</li> <li>coolors</li> <li>matplotlib</li> <li>prettyplotlib</li> <li>realpython</li> <li>viscm</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. The format is inspired by Keep a Changelog, and Element and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#0120-2024-08-11","title":"0.12.0 - 2024-08-11","text":""},{"location":"changelog/#api-changes-warning","title":"API changes warning \u26a0\ufe0f:","text":"<ul> <li>Drop Python 3.8 due to EOL. Please use v0.11.0.</li> </ul>"},{"location":"changelog/#added-features-and-improvements","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Goodbye setup.py, welcome modern Python packaging standards with <code>uv</code> and <code>ruff</code> \ud83c\udf89</li> <li>Added 3 variants of <code>paula</code> colormap: a cbf-friendly version <code>paula_cbf</code>, a continuous version <code>paula2</code>, and a green alternative <code>paula_lime</code></li> <li>Added beautiful GeoDataViz colormaps, checkout the gallery\ud83d\ude0e</li> </ul>"},{"location":"changelog/#other-changes","title":"Other changes:","text":"<ul> <li>Minor improvements</li> </ul>"},{"location":"changelog/#0110-2024-05-30","title":"0.11.0 - 2024-05-30","text":""},{"location":"changelog/#api-changes-warning_1","title":"API changes warning \u26a0\ufe0f:","text":"<ul> <li>The cmap <code>pastel_autunm</code> was renamed to <code>pastel_autumn</code></li> <li>Use <code>latex</code> font only if available</li> </ul>"},{"location":"changelog/#added-features-and-improvements_1","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Added tox setup with pytests against mpl 3.2-3.8 and py 3.8-3.12</li> <li>Added <code>pplt.show()</code> to get consistent sizing with <code>pplt.savefig</code></li> </ul>"},{"location":"changelog/#other-changes_1","title":"Other changes:","text":"<ul> <li>Move to new git repository: Welcome to Github\ud83c\udf89</li> <li>Removed deprecated function <code>setup_pyplot</code>, use <code>use_style</code></li> <li>Added option <code>reference_ax</code> parameter to specify axes in <code>pplt.savefig</code></li> </ul>"},{"location":"changelog/#0101-2023-11-27","title":"0.10.1 - 2023-11-27","text":""},{"location":"changelog/#bugfix","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Fixed bug when using <code>style='minimal'</code> that lead to altering custom ticks, see #1</li> </ul>"},{"location":"changelog/#0100-2023-03-09","title":"0.10.0 - 2023-03-09","text":""},{"location":"changelog/#api-changes-warning_2","title":"API changes warning \u26a0\ufe0f:","text":"<ul> <li>Renamed submodule <code>plot</code> to <code>pyplot</code> to avoid shadowing with function <code>pplt.plot</code></li> <li>Method <code>pplt.activate_axis</code> needs to be called via <code>pplt.pyplot.activate_axis</code></li> </ul>"},{"location":"changelog/#added-features-and-improvements_2","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Moved from pdoc to an all new <code>mkdocs</code> documentation \ud83c\udf89</li> </ul>"},{"location":"changelog/#bugfix_1","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Fixed bug with <code>label_outer</code> with mpl &gt;= 3.7</li> <li>Fixed bug due deprecation in mpl&gt;=3.6, where the kwarg <code>b</code> in <code>ax.grid</code> was renamed to <code>visibile</code></li> </ul>"},{"location":"changelog/#other-changes_2","title":"Other changes:","text":"<ul> <li>Some submodules, used to add additional pages in pdoc, were removed</li> <li>Remove deprecated usage of <code>mpl.cm.get_cmaps</code> and <code>mpl.cm.register_cmap</code></li> </ul>"},{"location":"changelog/#090-2022-04-28","title":"0.9.0 - 2022-04-28","text":""},{"location":"changelog/#api-changes-warning_3","title":"API changes warning \u26a0\ufe0f:","text":"<ul> <li>define <code>pip install prettypyplot[testing/docs/all]</code> to bundle installation</li> <li>The methods <code>pplt.tools.parse_figsize</code> and <code>pplt.tools.parse_figaratio</code> are moved to <code>pplt.style._parse_figsize</code> and <code>pplt.style._parse_figratio</code>, respectively</li> </ul>"},{"location":"changelog/#added-features-and-improvements_3","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Store all variables of <code>pplt.use_style</code>. This enables calling <code>pplt.update_style</code> without repeating all arguments remaining the same.</li> <li>Moved from <code>flat</code> to recommended <code>src</code> layout and moved tests from <code>test</code> to <code>tests</code></li> </ul>"},{"location":"changelog/#bugfix_2","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Fix coverage CI</li> <li>Fix identifying continuos cmaps in <code>pplt.use_style(colors=...)</code>, e.g., <code>turbo</code>, <code>viridis</code>.</li> <li>Fix calling <code>pplt.update_style</code> without specifying <code>figratio</code> and/or <code>figsize</code></li> <li>Fix including <code>LICENSE</code> file in pypi package and exclude tests, this allows publishing to conda-forge</li> </ul>"},{"location":"changelog/#other-changes_3","title":"Other changes:","text":"<ul> <li>Increase <code>decorit&gt;=0.2.0</code> to remove annoying PEP warnings</li> </ul>"},{"location":"changelog/#080-2022-04-03","title":"0.8.0 - 2022-04-03","text":""},{"location":"changelog/#api-changes-warning_4","title":"API changes warning \u26a0\ufe0f:","text":"<ul> <li>gray colors can not be accessed anymore via <code>default_grays['dark']</code> but instead via <code>default_grays.dark</code></li> </ul>"},{"location":"changelog/#added-features-and-improvements_4","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Added cmap <code>summertimes</code></li> <li>Scales markers and boxplots according to mode</li> <li>Added testing of plotting functionality pytest-mpl</li> <li><code>MODE</code> and <code>STYLE</code> are now of <code>Enum</code> class</li> <li>Major code improvements, see commits</li> </ul>"},{"location":"changelog/#bugfix_3","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Fix treating images (<code>imshow</code>) as none empty images</li> <li>Fix handling non subplot axes correctly by <code>pplt.hide_empty_axes</code></li> <li>Fix to activate minor and major grid for <code>mpl &gt;= 3.3</code> by calling <code>pplt.grid()</code></li> <li>Fix CI building docs</li> <li>Fix using wrong style/mode in <code>plot</code> submodule</li> </ul>"},{"location":"changelog/#071-2021-02-18","title":"0.7.1 - 2021-02-18","text":"<ul> <li>Fix uploading wrong package to PyPi</li> </ul>"},{"location":"changelog/#070-2021-02-17","title":"0.7.0 - 2021-02-17","text":""},{"location":"changelog/#added-features-and-improvements_5","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Added tests for basic functions (no figure comparisons)</li> <li>Major code clean up and refactoring</li> </ul>"},{"location":"changelog/#bugfix_4","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Fix restoring labels of outer axes when applying <code>pplt.hide_empty_axes</code></li> </ul>"},{"location":"changelog/#060-2021-01-14","title":"0.6.0 - 2021-01-14","text":""},{"location":"changelog/#added-features-and-improvements_6","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Add <code>pplt.subplot_labels</code> for adding shared labels for grid subplots</li> <li>Add pplt colors <code>pplt:lightgray</code> and <code>pplt:gray</code></li> <li>Added new gallery figure of subplots</li> </ul>"},{"location":"changelog/#050-2020-10-19","title":"0.5.0 - 2020-10-19","text":""},{"location":"changelog/#added-features-and-improvements_7","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>new refreshing colormap <code>paula</code></li> <li>Add <code>pplt.label_outer</code> which respects empty axes</li> <li>Add <code>pplt.hide_empty_axes</code> for hiding empty axes</li> </ul>"},{"location":"changelog/#bugfix_5","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Make cmaps compatible with <code>maptlitlib 3.5+</code></li> </ul>"},{"location":"changelog/#other-changes_4","title":"Other changes:","text":"<ul> <li>Enforce wemake-python-styleguide (WIP)</li> <li>Upgrade doc to <code>pdoc 0.9</code> and automatize it</li> </ul>"},{"location":"changelog/#042-2020-07-06","title":"0.4.2 - 2020-07-06","text":""},{"location":"changelog/#added-features-and-improvements_8","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Add option <code>sf</code> to activate sans-serif font with <code>pplt.use_style</code></li> <li>simplify usage of contour option</li> </ul>"},{"location":"changelog/#other-changes_5","title":"Other changes:","text":"<ul> <li>some code clean up</li> <li>skipped version due to error</li> </ul>"},{"location":"changelog/#040-2020-04-21","title":"0.4.0 - 2020-04-21","text":""},{"location":"changelog/#added-features-and-improvements_9","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Added Decorators</li> <li>Added 3 new discrete color options <code>'pastel_rainbow'</code>, <code>'pastel_spring'</code>, <code>'pastel_autumn'</code></li> <li>Refactor style settings. Added <code>pplt.update_style</code> and renamed <code>pplt.setup_pyplot</code> to <code>pplt.use_style</code></li> <li>Add text module with <code>pplt.text</code>, <code>pplt.figtext</code> and <code>pplt.add_contour</code>. With centered text and contour parameter</li> </ul>"},{"location":"changelog/#bugfix_6","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Minor bug fixes</li> </ul>"},{"location":"changelog/#other-changes_6","title":"Other changes:","text":"<ul> <li>Updated pydoc to 0.8.1</li> <li>Updated documentation and readme</li> </ul>"},{"location":"changelog/#030-2020-10-30","title":"0.3.0 - 2020-10-30","text":""},{"location":"changelog/#added-features-and-improvements_10","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Colors of <code>pastel5</code>, axes, grid and text are now accessible directly</li> </ul>"},{"location":"changelog/#bugfix_7","title":"Bugfix \ud83d\udc1b:","text":""},{"location":"changelog/#other-changes_7","title":"Other changes:","text":"<ul> <li>Increase simplification threshold to reduce figure size</li> <li>Minor changes</li> </ul>"},{"location":"changelog/#023-2020-02-04","title":"0.2.3 - 2020-02-04","text":"<ul> <li>Include mplstyle</li> </ul>"},{"location":"changelog/#022-2020-01-31","title":"0.2.2 - 2020-01-31","text":"<ul> <li>Fix PyPi setup</li> </ul>"},{"location":"changelog/#021-2020-01-31","title":"0.2.1 - 2020-01-31","text":""},{"location":"changelog/#added-features-and-improvements_11","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>added gallery</li> <li>added docs</li> </ul>"},{"location":"changelog/#bugfix_8","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>many small bugfixes</li> </ul>"},{"location":"changelog/#other-changes_8","title":"Other changes:","text":"<ul> <li>refactored all submodules</li> </ul>"},{"location":"contributing/","title":"Welcome to the <code>prettypyplot</code> Contributing Guide","text":"<p>This guide will give you an overview of the contribution workflow from opening an issue and creating a PR. To get an overview of the project, read the module overview.</p>"},{"location":"contributing/#issues","title":"Issues","text":""},{"location":"contributing/#create-a-new-issue","title":"Create a new issue","text":"<p>If you spot a bug, want to request a new functionality, or have a question on how to use the module, please search if an issue already exists. If a related issue does not exist, feel free to open a new issue.</p>"},{"location":"contributing/#solve-an-issue","title":"Solve an issue","text":"<p>If you want to contribute and do not how, feel free to scan through the existing issues.</p>"},{"location":"contributing/#create-a-new-pull-request","title":"Create a new pull request","text":""},{"location":"contributing/#create-a-fork","title":"Create a fork","text":"<p>If you want to request a change, you first have to fork the repository.</p>"},{"location":"contributing/#setup-a-development-environment","title":"Setup a development environment","text":"<p>First you need to install <code>uv</code>. Please follow the installation instruction provided on their page docs.astral.sh/uv.</p> <pre><code># setup venv\nuv sync --all-groups\n\n# install pre-commit\nuv run pre-commit install\n</code></pre>"},{"location":"contributing/#make-changes-and-run-tests","title":"Make changes and run tests","text":"<p>Apply your changes and check if you followed the codeing style (PEP8) by running <pre><code>uv run check --format\n</code></pre></p> <p>All errors pointing to <code>./build/</code> can be neglected, they are caused by my lazy approach of using no wildcards in the setup.</p> <p>If you add a new function/method/class please ensure that you add a test function, as well. Running the test simply by <pre><code># run tox\nuv run tox\n\n# or run it in parallel to speed it up\nuv run tox run-parallel\n</code></pre> And please ensure that the coverage does not decrease. Otherwise the CodeCov bot will complain.</p>"},{"location":"contributing/#open-a-pull-request","title":"Open a pull request","text":"<p>Now you are ready to open a pull request and wait on feedback.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#feature-x-is-missing","title":"Feature X is missing","text":"<p>First, if you are looking for a feature complete package, I would recommand you to take a look at seaborn, or use matplotlib directly. If you believe that a functionality/method/colormap is missing, feel free to open an issue and describe the missing feature and why it should be added. Alternatively, you can implement it yourself and create a PR to add it to this package, see contributing guide.</p>"},{"location":"faq/#i-found-a-bug-what-to-do-next","title":"I found a bug. What to do next?","text":"<p>If you find a bug in this package, it is very kind of you to open an issue/bug report. This allows us to identify and fix the problem, thus improving the overall quality of the software for all users. By providing a clear and concise description of the problem, including steps to reproduce it, and relevant information such as device, operating system, and software version, you will help us resolve the problem quickly and effectively. Submitting a bug report is a valuable contribution to the software and its community, and is greatly appreciated by the development team.</p>"},{"location":"faq/#how-to-cite-prettypyplot","title":"How to cite Prettypyplot?","text":"<p>If you want to cite prettypyplot in scientific work please use:</p> <p>Prettypyplot: publication ready matplotlib figures made simple D. Nagel, 2022. Zenodo: 10.5281/zenodo.7278312 On the Github sidebar you can also directly obtain the Apa or BibTex file.</p>"},{"location":"license/","title":"License","text":"<p>BSD 3-Clause License</p> <p>Copyright \u00a9 2019-2023, Daniel Nagel All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ul> <li> <p>Redistributions of source code must retain the above copyright notice, this   list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,   this list of conditions and the following disclaimer in the documentation   and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its   contributors may be used to endorse or promote products derived from   this software without specific prior written permission.</p> </li> </ul> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"gallery/","title":"Gallery of Examples","text":"<p>This page consists of a gallery with some example usage.</p> <p>colormaps </p> <p>legend </p> <p>colorbar </p> <p>logo </p>"},{"location":"gallery/cmaps/","title":"Colormaps","text":"<p>This module defines some perceptually uniform sequential and several qualitative colormaps. All of them can be loaded into matplotlib by <code>prettypyplot.colors.load_cmaps</code> or simply using the setup function <code>prettypyplot.style.use_style</code>. With <code>prettypyplot.colors.load_colors</code> the colors of <code>pastel5</code> (<code>'pplt:blue'</code>, <code>'pplt:red'</code>, <code>'pplt:green'</code>, <code>'pplt:orange'</code>, <code>'pplt:lightblue'</code>), of two gray shades <code>'pplt:gray'</code> and <code>'pplt:lightgray'</code>, axes <code>'pplt:axes'</code>, grid <code>'pplt:grid'</code> and textcolor <code>'pplt:text'</code> can be accessed easily.</p> <p>The qualitative colors <code>'pastel_autumn'</code>, <code>'pastel_spring'</code>, <code>'pastel_rainbow'</code> are neither colorblind friendly nor suited for black-white.</p> <p>Warning</p> <p>In the future colormaps might change slightly.</p> <p><code>viridis</code>, <code>jet</code>, <code>plasma</code> are only included here for comparison. Both, <code>macaw</code> and <code>bownair</code> are modified versions of <code>viridis</code>. While <code>turbo</code> tries to be a better <code>jet</code> (see here), <code>paula2</code> is a continuos version of <code>paula_cbf</code> and an alternative to <code>plasma</code>.</p> <p> </p> <p>All colormaps starting with <code>tol:</code> were designed by Paul Tol. All of them are colorblind friendly and some are even print friendly. For a detailed discussion check out his lovely blog.</p> <p></p> <p>And some beautiful taken from GeoDataViz. They should be all colorblind friendly. For more info please checkout GeoDataViz. The sequential colormaps with <code>s</code> are based on a single hue value, while <code>m</code> are multi-hue, and <code>d</code> are diverging.</p> <p></p> <p>For more colormaps see matplolib colormaps.</p>"},{"location":"gallery/colorbar/","title":"Colorbar","text":"<p>This is an example of using pplt.colorbar.</p> <p> </p> <pre><code>import numpy as np\nimport prettypyplot as pplt\nfrom matplotlib import pyplot as plt\n\n\n# create random data\nnp.random.seed(1337)\nn = int(1e6)\nx = np.random.standard_normal(n)\ny = x + np.random.standard_normal(n) / 2\nhist, xedges, yedges = np.histogram2d(x, y, bins=100, density=True)\nhist[hist == 0] = None\n\nfor style in ['default', 'minimal']:\n    pplt.use_style(style=style, figsize=(1.6, 1.6))\n\n    # legend\n    fig, axs = plt.subplots(1, 2, gridspec_kw={'wspace': 0.3})\n    for ax, position in zip(axs, ['top', 'right']):\n        im = pplt.imshow(\n            hist,\n            extent=[x.min(), x.max(), y.min(), y.max()],\n            ax=ax,\n        )\n</code></pre>"},{"location":"gallery/legend/","title":"Legend","text":"<p>This is an example of using pplt.legend.</p> <p>Note</p> <p>If you want to disable the border for the default style you can simply rely on the matplotlib parameter and pass <code>frameon = False</code> to the method, for more parameters check out matplotlib.pyplot.legend.</p> <p> </p> <pre><code>import numpy as np\nimport prettypyplot as pplt\nfrom matplotlib import pyplot as plt\n\n# define random data to plot\nnp.random.seed(1337)\nN = 500\nT = np.linspace(0, 3 * np.pi, N)\nX1, X2 = [\n    np.sin(T + np.pi * np.random.rand()) + 0.1 * np.random.rand(N) for _ in range(2)\n]\n\n# loop over  random data to plot\nfor style in ['default', 'minimal']:\n    pplt.use_style(style=style, figsize=1.2)\n\n    fig, axs = plt.subplots(1, 3, gridspec_kw={'wspace': 0.25})\n\n    # legend\n    for i, outside in enumerate(['top', False, 'right']):\n        ax = axs.flatten()[i]\n        pplt.plot(T, X1, ax=ax, label='$x_1$')\n        pplt.plot(T, X2, ax=ax, label='$x_2$')\n\n        pplt.legend(title='title', ax=ax, outside=outside)\n\n    pplt.savefig(f'images/legend_{style}.svg')\n</code></pre>"},{"location":"gallery/logo/","title":"Logo","text":"<p>This is an example how the pplt icon is created.</p> <p></p> <pre><code>\"\"\"Create Matplotlib inspired logo.\n\nThis script is taken from\nhttps://matplotlib.org/gallery/misc/logos2.html#sphx-glr-gallery-misc-logos2-py\nan heavily simplified to fit the spirit of prettypyplot.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.patches import Rectangle\n\nimport prettypyplot as pplt\n\n\ndef create_icon_axes(fig):\n    \"\"\"Create a polar axes containing the radar plot.\"\"\"\n    ax = fig.add_axes((0, 0, 1, 1), projection='polar')\n\n    N = 7\n    arc = 2.0 * np.pi\n    theta = np.arange(0.0, arc, arc / N)\n    radii = np.array([3, 6, 8, 7, 4, 5, 8])\n    bars = ax.bar(\n        theta,\n        radii,\n        width=arc / N,\n        bottom=0.0,\n        align='edge',\n        edgecolor=plt.rcParams['text.color'],\n    )\n    for r, bar in zip(radii, bars):\n        val = (r - radii.min()) / (radii.max() - radii.min())\n        color = plt.get_cmap('macaw')(val)\n        bar.set_facecolor(color)\n\n    ax.tick_params(\n        labelbottom=False,\n        labeltop=False,\n        labelleft=False,\n        labelright=False,\n    )\n    ax.set_rmax(9.5)\n\n    # the actual visible background - extends a bit beyond the axis\n    ax.add_patch(\n        Rectangle(\n            (0, 0),\n            arc,\n            10.5,\n            facecolor='white',\n            zorder=0,\n            clip_on=False,\n            in_layout=False,\n        )\n    )\n    return ax\n\n\ndef make_slogan():\n    \"\"\"Create a slogan of the prettypyplot logo.\"\"\"\n    pplt.figtext(\n        1.15,\n        1.05,\n        'prettypyplot',\n        va='top',\n        ha='left',\n        fontsize=8,\n        weight='bold',\n        fontname='Roboto',\n    )\n\n    _, clight, _, _ = pplt.categorical_color(4, 'pplt:gray')\n    pplt.figtext(\n        1.15,\n        -0.05,\n        'Publication ready\\nmatplotlib figures\\nmade simple',\n        va='bottom',\n        ha='left',\n        fontsize=5,\n        color=clight,\n        fontname='Roboto',\n    )\n\n\npplt.use_style(figsize=(0.35, 0.35), latex=False)\nfig = plt.figure()\nax = create_icon_axes(fig)\nmake_slogan()\npplt.savefig('images/logo_large.svg')\n</code></pre>"},{"location":"reference/","title":"prettypyplot","text":""},{"location":"reference/#prettypyplot--prettypyplot","title":"Prettypyplot","text":"<p>This package provides helper functions to easen the usage of matplotlib.</p> <p>The module is structured into the following submodules:</p> <ul> <li> <p>pyplot: This submodule contains all methods   related to plotting inside a single axes, so basically related to   matplotlib.pyplot.</p> </li> <li> <p>style: This module provides only method to load   and alter the current style.</p> </li> <li> <p>subplots: This module provides methods to   simplify dealing with matplotlib.pyplot.subplots grids.</p> </li> <li> <p>texts: This module provides methods to   plot text with the possibility to add a contour.</p> </li> <li> <p>tools: This module provides utility methods to.</p> </li> </ul>"},{"location":"reference/#prettypyplot.categorical_cmap","title":"<code>categorical_cmap(nc, nsc, *, cmap=None, return_colors=False)</code>","text":"<p>Generate categorical colors of given cmap.</p> <p>Exract from a predefined colormap colors and generate for each the desired number of shades.</p> <p>Parameters:</p> <ul> <li> <code>nc</code>               (<code>int</code>)           \u2013            <p>Number of colors</p> </li> <li> <code>nsc</code>               (<code>int</code>)           \u2013            <p>Number of shades per colors</p> </li> <li> <code>cmap</code>               (<code>`matplotlib.colors.Colormap` or str</code>, default:                   <code>None</code> )           \u2013            <p>Matplotlib colormap to take colors from. The default is the active color cycle.</p> </li> <li> <code>return_colors</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return an array of rgb colors. Each color together with its shades are in an own row.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>scolors</code> (              <code>`matplotlib.colors.Colormap` or np.ndarray</code> )          \u2013            <p>Return discrete colormap. If return_colors, a 2d representation will be returned instead.</p> </li> </ul> Source code in <code>src/prettypyplot/colors.py</code> <pre><code>def categorical_cmap(nc, nsc, *, cmap=None, return_colors=False):\n    \"\"\"Generate categorical colors of given cmap.\n\n    Exract from a predefined colormap colors and generate for each the desired\n    number of shades.\n\n    Parameters\n    ----------\n    nc : int\n        Number of colors\n    nsc : int\n        Number of shades per colors\n    cmap : `matplotlib.colors.Colormap` or str, optional\n        Matplotlib colormap to take colors from. The default is the active\n        color cycle.\n    return_colors : bool, optional\n        Return an array of rgb colors. Each color together with its shades are\n        in an own row.\n\n    Returns\n    -------\n    scolors : `matplotlib.colors.Colormap` or np.ndarray\n        Return discrete colormap. If return_colors, a 2d representation will\n        be returned instead.\n\n    \"\"\"\n    # check correct data type\n    _is_number_in_range(\n        nc,\n        name='nc',\n        dtype=int,\n        low=1,\n        high=np.iinfo(int).max,\n    )\n    _is_number_in_range(\n        nsc,\n        name='nsc',\n        dtype=int,\n        low=1,\n        high=np.iinfo(int).max,\n    )\n    nc, nsc = int(nc), int(nsc)\n\n    # get cmap\n    if cmap is not None:\n        cmap = plt.get_cmap(cmap)\n    else:\n        cmap = clr.ListedColormap(\n            plt.rcParams['axes.prop_cycle'].by_key()['color'],\n        )\n    if nc &gt; cmap.N:\n        raise ValueError('Too many categories for colormap.')\n\n    # extract colors from cmap\n    if isinstance(cmap, clr.LinearSegmentedColormap):\n        colors = cmap(np.linspace(0, 1, nc))\n    elif isinstance(cmap, clr.ListedColormap):\n        colors = cmap(np.arange(nc, dtype=int))\n\n    # get shades of colors\n    scolors = np.empty((nc, nsc, 3))\n    for idx, color in enumerate(colors):\n        scolors[idx] = categorical_color(nsc, color)\n\n    if return_colors:\n        return scolors\n    return clr.ListedColormap(np.concatenate(scolors))\n</code></pre>"},{"location":"reference/#prettypyplot.categorical_color","title":"<code>categorical_color(nsc, color, *, return_hex=False)</code>","text":"<p>Generate categorical shades of given colors.</p> <p>Generate for each provided color the number of specified shades. The shaded colors are interpolated linearly in HSV colorspace. This function is based on following post: https://stackoverflow.com/a/47232942</p> <p>Parameters:</p> <ul> <li> <code>nsc</code>               (<code>int</code>)           \u2013            <p>Number of shades per color.</p> </li> <li> <code>color</code>               (<code>RGB color or matplotlib predefined color</code>)           \u2013            <p>Color used for generating shades.</p> </li> <li> <code>return_hex</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return colors in hex format instead of rgb.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>colors_rgb</code> (              <code>list of RGB colors</code> )          \u2013            <p>A list containing shaded colors. Where the list is sorted from the original color at the beginning to the most shaded one at the end. The default color encoding is rgb and hex if specified.</p> </li> </ul> Source code in <code>src/prettypyplot/colors.py</code> <pre><code>def categorical_color(nsc, color, *, return_hex=False):\n    \"\"\"Generate categorical shades of given colors.\n\n    Generate for each provided color the number of specified shades. The shaded\n    colors are interpolated linearly in HSV colorspace. This function is based\n    on following post: https://stackoverflow.com/a/47232942\n\n    Parameters\n    ----------\n    nsc : int\n        Number of shades per color.\n    color : RGB color or matplotlib predefined color\n        Color used for generating shades.\n    return_hex : bool, optional\n        Return colors in hex format instead of rgb.\n\n    Returns\n    -------\n    colors_rgb : list of RGB colors\n        A list containing shaded colors. Where the list is sorted from the\n        original color at the beginning to the most shaded one at the end.\n        The default color encoding is rgb and hex if specified.\n\n    \"\"\"\n    # check correct data type\n    color = clr.to_rgb(color)\n    _is_number_in_range(\n        nsc,\n        name='nsc',\n        dtype=int,\n        low=1,\n        high=np.iinfo(int).max,\n    )\n    nsc = int(nsc)\n\n    # genrate shades of colors\n    color_hsv = clr.rgb_to_hsv(color)\n    colors_hsv = np.tile(color_hsv, nsc).reshape(nsc, 3)\n    colors_hsv[:, 1] = np.linspace(color_hsv[1], 1 / 4, nsc)\n    colors_hsv[:, 2] = np.linspace(color_hsv[2], 1, nsc)\n    colors_rgb = clr.hsv_to_rgb(colors_hsv)\n\n    # check if color is greyscale value, need to fix arbitrary hue value of 0\n    if is_greyshade(color):\n        colors_rgb[:, 0] = colors_rgb[:, 1]\n\n    if return_hex:\n        return [clr.to_hex(color) for color in colors_rgb]\n    return colors_rgb\n</code></pre>"},{"location":"reference/#prettypyplot.load_cmaps","title":"<code>load_cmaps()</code>","text":"<p>Load and include custom colormaps to matplotlib.</p> <p>Add sequential colormaps <code>pastel5</code>, <code>pastel6</code>, <code>cbf4</code>, <code>cbf5</code>, <code>cbf8</code>, and <code>ufcd</code> as an corporate design. Except of <code>ufcd</code> all palettes should be 'color-blind-friendly'.</p> <p>Add continuous colormaps macaw, Turbo. The Copyright of those are given on top of the data.</p> <p>See</p> <p>Choosing an cmaps.</p> Source code in <code>src/prettypyplot/colors.py</code> <pre><code>def load_cmaps():\n    \"\"\"Load and include custom colormaps to matplotlib.\n\n    Add sequential colormaps `pastel5`, `pastel6`, `cbf4`, `cbf5`, `cbf8`,\n    and `ufcd` as an corporate design. Except of `ufcd` all palettes should be\n    'color-blind-friendly'.\n\n    Add continuous colormaps macaw, Turbo. The Copyright of those are given on\n    top of the data.\n\n    !!! see\n        Choosing an [cmaps](../../gallery/cmaps).\n\n    \"\"\"\n    colormaps = (\n        _argon(),\n        _pastel5(),\n        _pastel6(),\n        _cbf4(),\n        _cbf5(),\n        _cbf8(),\n        _gdv_rag(),\n        _gdv_rag_cvd(),\n        _gdv_palette(),\n        _gdv_6a(),\n        _gdv_5a(),\n        _gdv_4a(),\n        _gdv_4b(),\n        _gdv_3a(),\n        _gdv_3b(),\n        _gdv_2a(),\n        _gdv_2b(),\n        _gdv_s1(),\n        _gdv_s2(),\n        _gdv_s3(),\n        _gdv_m1(),\n        _gdv_m2(),\n        _gdv_m3(),\n        _gdv_d1(),\n        _gdv_d2(),\n        _gdv_d3(),\n        _gdv_d4(),\n        _gdv_mars(),\n        _gdv_moon(),\n        _pastel_autumn(),\n        _pastel_rainbow(),\n        _pastel_spring(),\n        _paula(),\n        _paula2(),\n        _paula_cbf(),\n        _paula_lime(),\n        _summertimes(),\n        _tol_bright(),\n        _tol_high_contrast(),\n        _tol_light(),\n        _tol_medium_contrast(),\n        _tol_muted(),\n        _tol_vibrant(),\n        _ufcd(),\n        _turbo(),\n        _macaw(),\n        _bownair(),\n    )\n    # register own continuous and discrete cmaps\n    for colormap in colormaps:\n        # add cmap and reverse cmap\n        for cmap in (colormap, colormap.reversed()):\n            try:\n                _get_cmap(cmap.name)\n            except ValueError:\n                _register_cmap(cmap=cmap)\n</code></pre>"},{"location":"reference/#prettypyplot.load_colors","title":"<code>load_colors()</code>","text":"<p>Load and include custom colors to matplotlib.</p> <p>Add colors of <code>pastel5</code> which can be accessed via <code>pplt:blue</code>, <code>pplt:red</code>, <code>pplt:green</code>, <code>pplt:orange</code>, <code>pplt:lightblue</code>, <code>pplt:gray</code> and <code>pplt:lightgray</code>. Further, the current colors will be added <code>pplt:axes</code>, <code>pplt:text</code>, <code>pplt:grid</code>.</p> <p>See</p> <p>Choosing an cmaps.</p> Source code in <code>src/prettypyplot/colors.py</code> <pre><code>def load_colors():\n    \"\"\"Load and include custom colors to matplotlib.\n\n    Add colors of `pastel5` which can be accessed via `pplt:blue`, `pplt:red`,\n    `pplt:green`, `pplt:orange`, `pplt:lightblue`, `pplt:gray` and\n    `pplt:lightgray`. Further, the current colors will be added `pplt:axes`,\n    `pplt:text`, `pplt:grid`.\n\n    !!! see\n        Choosing an [cmaps](../../gallery/cmaps).\n\n    \"\"\"\n    # register own colors\n    pplt_colors = {\n        'pplt:blue': _pastel5().colors[0],\n        'pplt:red': _pastel5().colors[1],\n        'pplt:green': _pastel5().colors[2],\n        'pplt:orange': _pastel5().colors[3],\n        'pplt:lightblue': _pastel5().colors[4],\n        'pplt:gray': default_grays.dark,\n        'pplt:grey': default_grays.dark,\n        'pplt:lightgray': default_grays.light,\n        'pplt:lightgrey': default_grays.light,\n        'pplt:axes': plt.rcParams['axes.edgecolor'],\n        'pplt:text': plt.rcParams['text.color'],\n        'pplt:grid': plt.rcParams['grid.color'],\n    }\n    clr._colors_full_map.update(pplt_colors)\n</code></pre>"},{"location":"reference/#prettypyplot.text_color","title":"<code>text_color(bgcolor, colors=('#000000', '#ffffff'))</code>","text":"<p>Select textcolor with maximal contrast on background.</p> <p>All parameters needs to be colors accepted by matplotlib, see matplotlib.colors. The formulas are taken from W3C WCAG 2.1 (Web Content Accessibility Guidelines).</p> <p>Parameters:</p> <ul> <li> <code>bgcolor</code>               (<code>matplotlib color</code>)           \u2013            <p>Background color to which the contrast is maximized.</p> </li> <li> <code>colors</code>               (<code>list of matplotlib colors</code>, default:                   <code>('#000000', '#ffffff')</code> )           \u2013            <p>Selection of textcolors to choose from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>color</code> (              <code>matplotlib color</code> )          \u2013            <p>Color of colors which has the highest contrast on the given bgcolor.</p> </li> </ul> Source code in <code>src/prettypyplot/colors.py</code> <pre><code>def text_color(bgcolor, colors=('#000000', '#ffffff')):\n    \"\"\"Select textcolor with maximal contrast on background.\n\n    All parameters needs to be colors accepted by matplotlib, see\n    [matplotlib.colors](https://matplotlib.org/api/colors_api.html).\n    The formulas are taken from W3C [WCAG 2.1](https://www.w3.org/TR/WCAG21)\n    (Web Content Accessibility Guidelines).\n\n    Parameters\n    ----------\n    bgcolor : matplotlib color\n        Background color to which the contrast is maximized.\n    colors : list of matplotlib colors, optional\n        Selection of textcolors to choose from.\n\n    Returns\n    -------\n    color : matplotlib color\n        Color of colors which has the highest contrast on the given bgcolor.\n\n    \"\"\"\n    # check input by casting to matplotlib colors\n    bgcolor = clr.to_rgb(bgcolor)\n    colors_rgb = [clr.to_rgb(color) for color in colors]\n\n    # calculate the (luminances)\n    bgL = _relative_luminance(bgcolor)\n    Ls = [_relative_luminance(color) for color in colors_rgb]\n\n    # calculate contrast between bgcolor and all colors\n    contrast = [_contrast(bgL, Luminance) for Luminance in Ls]\n\n    # return color corresponding to greatest contrast\n    idx = contrast.index(max(contrast))\n    return colors[idx]\n</code></pre>"},{"location":"reference/#prettypyplot.update_style","title":"<code>update_style(interactive=None, colors=None, cmap=None, ncs=None, figsize=None, figratio=None, mode=None, style=None, ipython=None, true_black=None, latex=None, sf=None)</code>","text":"<p>Update alternative matplotlib style.</p> <p>This function updates specified parameters of <code>use_style</code> without changing other.</p> <p>Parameters:</p> <ul> <li> <code>interactive</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Set interactive mode.</p> </li> <li> <code>colors</code>               (<code>string</code>, default:                   <code>None</code> )           \u2013            <p>Set the default color cycler from continuous or discrete maps. Use any of matplotlibs defaults or specified in the colors submodule.</p> </li> <li> <code>cmap</code>               (<code>string</code>, default:                   <code>None</code> )           \u2013            <p>Set the default colormap.</p> </li> <li> <code>ncs</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of colors if continuous cmap is selected.</p> </li> <li> <code>figsize</code>               (<code>int or int tuple</code>, default:                   <code>None</code> )           \u2013            <p>Give size of default figure in inches, either as tuple (x, y) or a single float for the x-axis. The y-axis will be determined by figratio.</p> </li> <li> <code>figratio</code>               (<code>str or float</code>, default:                   <code>None</code> )           \u2013            <p>Set ratio of figsize x:y to 1:1/'option', where 'option' is one of <code>['sqrt(2)', 'golden', 'sqrt(3)']</code> or any number. Golden stands for the golden ratio (1.618). This option is ignored if figsize is used with tuple.</p> </li> <li> <code>mode</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>One of the following modes: <code>'default'</code>: use matplotlib defaults <code>'beamer'</code>: extra large fontsize <code>'print'</code>: default sizes <code>'poster'</code>: for Din A0 posters</p> </li> <li> <code>style</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>One of the following styles: <code>'default'</code>: enables grid and upper and right spines <code>'minimal'</code>: removes all unneeded lines <code>'none'</code>: no changes to style</p> </li> <li> <code>ipython</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Deactivate high-res in jpg/png for compatibility with IPyhton, e.g. jupyter notebook/lab.</p> </li> <li> <code>true_black</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>If true black will be used for labels and co., else a dark grey.</p> </li> <li> <code>latex</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>If true LaTeX font will be used.</p> </li> <li> <code>sf</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Use sans-serif font for text and latex math environment.</p> </li> </ul> Source code in <code>src/prettypyplot/style.py</code> <pre><code>def update_style(  # noqa: C901\n    interactive=None,\n    colors=None,\n    cmap=None,\n    ncs=None,\n    figsize=None,\n    figratio=None,\n    mode=None,\n    style=None,\n    ipython=None,\n    true_black=None,\n    latex=None,\n    sf=None,\n):\n    \"\"\"Update alternative matplotlib style.\n\n    This function updates specified parameters of `use_style` without changing\n    other.\n\n    Parameters\n    ----------\n    interactive : bool, optional\n        Set interactive mode.\n    colors : string, optional\n        Set the default color cycler from continuous or discrete maps. Use any\n        of matplotlibs defaults or specified in the colors submodule.\n    cmap : string, optional\n        Set the default colormap.\n    ncs : int, optional\n        Number of colors if continuous cmap is selected.\n    figsize : int or int tuple, optional\n        Give size of default figure in inches, either as tuple (x, y) or a\n        single float for the x-axis. The y-axis will be determined by figratio.\n    figratio : str or float, optional\n        Set ratio of figsize x:y to 1:1/'option', where 'option' is one\n        of `['sqrt(2)', 'golden', 'sqrt(3)']` or any number. Golden stands for\n        the golden ratio (1.618). This option is ignored if figsize is used\n        with tuple.\n    mode : str, optional\n        One of the following modes:\n        `'default'`: use matplotlib defaults\n        `'beamer'`: extra large fontsize\n        `'print'`: default sizes\n        `'poster'`: for Din A0 posters\n    style : str, optional\n        One of the following styles:\n        `'default'`: enables grid and upper and right spines\n        `'minimal'`: removes all unneeded lines\n        `'none'`: no changes to style\n    ipython : bool, optional\n        Deactivate high-res in jpg/png for compatibility with IPyhton, e.g.\n        jupyter notebook/lab.\n    true_black : bool, optional\n        If true black will be used for labels and co., else a dark grey.\n    latex : bool, optional\n        If true LaTeX font will be used.\n    sf : bool, optional\n        Use sans-serif font for text and latex math environment.\n\n    \"\"\"\n    # set selected mode and style\n    if style is not None:\n        if isinstance(style, Style):\n            pass\n        elif isinstance(style, str) and style.upper() in Style.keys_list():\n            style = Style[style.upper()]\n        else:\n            raise ValueError(\n                'Style \"{st}\" is not supported, use one of {sts}.'.format(\n                    st=style,\n                    sts=Style.keys_list(),\n                ),\n            )\n        _pplt.STYLE = style\n\n    if mode is not None:\n        if isinstance(mode, Mode):\n            pass\n        elif isinstance(mode, str) and mode.upper() in Mode.keys_list():\n            mode = Mode[mode.upper()]\n        else:\n            raise ValueError(\n                'Mode \"{mode}\" is not supported, use one of {modes}.'.format(\n                    mode=mode,\n                    modes=Mode.keys_list(),\n                ),\n            )\n\n        _pplt.MODE = mode\n\n    # set style variables in dictionary\n    for key, val in (\n        ('interactive', interactive),\n        ('colors', colors),\n        ('cmap', cmap),\n        ('ncs', ncs),\n        ('figsize', figsize),\n        ('figratio', figratio),\n        ('ipython', ipython),\n        ('true_black', true_black),\n        ('latex', latex),\n        ('sf', sf),\n    ):\n        if val is not None:\n            _pplt.STYLE_DICT[key] = val\n\n    if _pplt.STYLE is Style.NONE:\n        _reset_style()\n    else:\n        # load static rcParams\n        _apply_style('stylelib/default.mplstyle')\n        if _pplt.STYLE is Style.MINIMAL:\n            _apply_style('stylelib/minimal.mplstyle')\n\n        # set color cycle and cmap\n        _set_rc_colors(\n            colors=colors,\n            cmap=cmap,\n            ncs=ncs,\n            true_black=true_black,\n        )\n\n        # set figsize\n        if figsize is not None:\n            _set_rc_figsize(figratio=figratio, figsize=figsize)\n\n        # increase dpi if not in iypthon\n        _set_rc_dpi(ipython)\n\n        # set interactive mode\n        _set_ineractive_mode(interactive=interactive)\n\n        # setup LaTeX font if latex is available\n        # plt.style.use can not be used.\n        if latex and shutil.which('latex'):\n            _apply_style('stylelib/latex.mplstyle')\n\n        if sf:\n            _set_rc_sansserif()\n\n    if mode is not None:\n        # change widths and fontsize depending on MODE\n        _set_rc_widths(mode)\n</code></pre>"},{"location":"reference/#prettypyplot.use_style","title":"<code>use_style(interactive=None, colors='pastel5', cmap='macaw', ncs=10, figsize=(3,), figratio='golden', mode=_pplt.MODE, style=_pplt.STYLE, ipython=False, true_black=False, latex=True, sf=False)</code>","text":"<p>Define alternative matplotlib style.</p> <p>This function restores first the matplolib default values and finally changes depicted values to achieve a more appealing appearence. It additionally loads pplts colormaps and colors in matplolib.</p> <p>See update_style for parameters.</p> Source code in <code>src/prettypyplot/style.py</code> <pre><code>@copy_doc_params(update_style)\ndef use_style(\n    interactive=None,\n    colors='pastel5',\n    cmap='macaw',\n    ncs=10,\n    figsize=(3,),\n    figratio='golden',\n    mode=_pplt.MODE,\n    style=_pplt.STYLE,\n    ipython=False,\n    true_black=False,\n    latex=True,\n    sf=False,\n):\n    \"\"\"Define alternative matplotlib style.\n\n    This function restores first the matplolib default values and finally\n    changes depicted values to achieve a more appealing appearence.\n    It additionally loads pplts colormaps and colors in matplolib.\n\n    See [update_style][prettypyplot.update_style] for parameters.\n\n    \"\"\"\n    # restore matplotlib defaults\n    _reset_style()\n\n    # register own continuous and discrete cmaps\n    pclr.load_cmaps()\n\n    # update style\n    update_style(\n        interactive=interactive,\n        colors=colors,\n        cmap=cmap,\n        ncs=ncs,\n        figsize=figsize,\n        figratio=figratio,\n        mode=mode,\n        style=style,\n        ipython=ipython,\n        true_black=true_black,\n        latex=latex,\n        sf=sf,\n    )\n\n    # register used colors\n    pclr.load_colors()\n</code></pre>"},{"location":"reference/#prettypyplot.add_contour","title":"<code>add_contour(txt, contourwidth, contourcolor='w')</code>","text":"<p>Draw contour around txt.</p> <p>Parameters:</p> <ul> <li> <code>txt</code>               (<code>mpl Text</code>)           \u2013            <p>Instance of matplotlib.text.Text. Can be obtained by, e.g., <code>txt = plt.text()</code> or <code>txt = plt.figtext()</code>.</p> </li> <li> <code>contourwidth</code>               (<code>scalar</code>)           \u2013            <p>Width of contour.</p> </li> <li> <code>contourcolor</code>               (<code>RGB color or matplotlib predefined color</code>, default:                   <code>'w'</code> )           \u2013            <p>Color of contour, default is white.</p> </li> </ul> Source code in <code>src/prettypyplot/texts.py</code> <pre><code>def add_contour(txt, contourwidth, contourcolor='w'):\n    r\"\"\"Draw contour around txt.\n\n    Parameters\n    ----------\n    txt : mpl Text\n        Instance of [matplotlib.text.Text][]. Can be obtained by, e.g.,\n        `txt = plt.text()` or `txt = plt.figtext()`.\n    contourwidth : scalar\n        Width of contour.\n    contourcolor : RGB color or matplotlib predefined color, optional\n        Color of contour, default is white.\n\n    \"\"\"\n    # check if is text object\n    if not isinstance(txt, mpl.text.Text):\n        raise TypeError(\n            'txt needs to be \"matplotlib.text.Text\", but ' + 'is {t}'.format(t=txt),\n        )\n    # check if number\n    if not tools.is_number(contourwidth):\n        raise TypeError(\n            'contourwidth={w} needs to be a number.'.format(w=contourwidth),\n        )\n\n    # check if color\n    if not clr.is_color_like(contourcolor):\n        raise TypeError(\n            'contourcolor={c} can not be '.format(c=contourcolor)\n            + 'interpreted as color.',\n        )\n\n    path_args = [\n        path_effects.withStroke(\n            linewidth=contourwidth,\n            foreground=contourcolor,\n        )\n    ]\n    txt.set_path_effects(path_args)\n</code></pre>"},{"location":"reference/#prettypyplot.figtext","title":"<code>figtext(x, y, s, *, contour=None, **kwargs)</code>","text":"<p>Generate text object at figure position (x,y).</p> <p>Wrapper around pyplot.figtext. The default alignment is changed to centered.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>scalars</code>)           \u2013            <p>The position to place the text. By default, this is in data coordinates. The coordinate system can be changed using the <code>transform</code> parameter.</p> </li> <li> <code>y</code>               (<code>scalars</code>)           \u2013            <p>The position to place the text. By default, this is in data coordinates. The coordinate system can be changed using the <code>transform</code> parameter.</p> </li> <li> <code>s</code>               (<code>str</code>)           \u2013            <p>The text.</p> </li> <li> <code>contour</code>               (<code>bool or tuple(scalar, color)</code>, default:                   <code>None</code> )           \u2013            <p>Add a contour to the text. Either use a boolean for default values, or give a tuple with linewidth and linecolor.</p> </li> <li> <code>ax</code>               (<code>matplotlib axes</code>)           \u2013            <p>Matplotlib axes to plot in.</p> </li> <li> <code>kwargs</code>           \u2013            <p>Text properties of matplotlib.pyplot.figtext</p> </li> </ul> Source code in <code>src/prettypyplot/texts.py</code> <pre><code>def figtext(x, y, s, *, contour=None, **kwargs):\n    \"\"\"Generate text object at figure position (x,y).\n\n    Wrapper around pyplot.figtext. The default alignment is changed to\n    centered.\n\n    Parameters\n    ----------\n    x, y : scalars\n        The position to place the text. By default, this is in data\n        coordinates. The coordinate system can be changed using the\n        `transform` parameter.\n    s : str\n        The text.\n    contour : bool or tuple(scalar, color)\n        Add a contour to the text. Either use a boolean for default values,\n        or give a tuple with linewidth and linecolor.\n    ax : matplotlib axes\n        Matplotlib axes to plot in.\n    kwargs\n        Text properties of [matplotlib.pyplot.figtext][]\n\n    \"\"\"\n    # change default alignment\n    if 'va' not in kwargs and 'verticalalignment' not in kwargs:\n        kwargs['va'] = 'center'\n    if 'ha' not in kwargs and 'horizontalalignment' not in kwargs:\n        kwargs['ha'] = 'center'\n\n    # plot text\n    txt = plt.figtext(x=x, y=y, s=s, **kwargs)\n\n    # generate contour\n    if contour is not None:\n        contour_kwargs = _parse_contour(contour)\n        if contour_kwargs is not None:\n            add_contour(txt, **contour_kwargs)\n\n    return txt\n</code></pre>"},{"location":"reference/#prettypyplot.text","title":"<code>text(x, y, s, *, contour=None, ax=None, **kwargs)</code>","text":"<p>Generate text object at (x,y).</p> <p>Wrapper around pyplot.text. The default alignment is changed to centered.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>scalars</code>)           \u2013            <p>The position to place the text. By default, this is in data coordinates. The coordinate system can be changed using the transform parameter.</p> </li> <li> <code>y</code>               (<code>scalars</code>)           \u2013            <p>The position to place the text. By default, this is in data coordinates. The coordinate system can be changed using the transform parameter.</p> </li> <li> <code>s</code>               (<code>str</code>)           \u2013            <p>The text.</p> </li> <li> <code>contour</code>               (<code>bool or tuple(scalar, color)</code>, default:                   <code>None</code> )           \u2013            <p>Add a contour to the text. Either use a boolean for default values, or give a tuple with linewidth and linecolor.</p> </li> <li> <code>ax</code>               (<code>matplotlib axes</code>, default:                   <code>None</code> )           \u2013            <p>Matplotlib axes to plot in.</p> </li> <li> <code>kwargs</code>           \u2013            <p>Text properties of matplotlib.pyplot.text</p> </li> </ul> Source code in <code>src/prettypyplot/texts.py</code> <pre><code>def text(x, y, s, *, contour=None, ax=None, **kwargs):\n    \"\"\"Generate text object at (x,y).\n\n    Wrapper around pyplot.text. The default alignment is changed to centered.\n\n    Parameters\n    ----------\n    x, y : scalars\n        The position to place the text. By default, this is in data\n        coordinates. The coordinate system can be changed using the\n        *transform* parameter.\n    s : str\n        The text.\n    contour : bool or tuple(scalar, color)\n        Add a contour to the text. Either use a boolean for default values,\n        or give a tuple with linewidth and linecolor.\n    ax : matplotlib axes\n        Matplotlib axes to plot in.\n    kwargs\n        Text properties of [matplotlib.pyplot.text][]\n\n    \"\"\"\n    # parse axes\n    ax = tools.gca(ax)\n\n    # change default alignment\n    if 'va' not in kwargs and 'verticalalignment' not in kwargs:\n        kwargs['va'] = 'center'\n    if 'ha' not in kwargs and 'horizontalalignment' not in kwargs:\n        kwargs['ha'] = 'center'\n\n    # plot text\n    txt = ax.text(x=x, y=y, s=s, **kwargs)\n\n    # generate contour\n    if contour is not None:\n        contour_kwargs = _parse_contour(contour)\n        if contour_kwargs is not None:\n            add_contour(txt, **contour_kwargs)\n\n    return txt\n</code></pre>"},{"location":"reference/#prettypyplot.hide_empty_axes","title":"<code>hide_empty_axes(axs=None)</code>","text":"<p>Hide empty axes.</p> <p>Loop over all axes and hide empty ones.</p> <p>Parameters:</p> <ul> <li> <code>axs</code>               (<code>mpl.axes.Axes or list of</code>, default:                   <code>None</code> )           \u2013            <p>Specify matplotlib.axes.Axes to check for empty state. Default use all of current figure.</p> </li> </ul> Source code in <code>src/prettypyplot/subplots.py</code> <pre><code>def hide_empty_axes(axs=None):\n    \"\"\"Hide empty axes.\n\n    Loop over all axes and hide empty ones.\n\n    Parameters\n    ----------\n    axs : mpl.axes.Axes or list of\n        Specify [matplotlib.axes.Axes][] to check for empty state. Default use\n        all of current figure.\n\n    \"\"\"\n    # check for single axes\n    axs = tools.get_axes(axs)\n\n    # loop over all axes and hide empty ones\n    for ax in axs:\n        if _is_empty_axes(ax):\n            ax.axis('off')\n\n    # in case of shared axes, activate outer tick labels\n    _activate_outer_ticks(axs)\n</code></pre>"},{"location":"reference/#prettypyplot.label_outer","title":"<code>label_outer(axs=None)</code>","text":"<p>Only show outer labels and tick labels.</p> <p>This checks for outest visible axes only. Works only with single Gridspec.</p> <p>Parameters:</p> <ul> <li> <code>axs</code>               (<code>mpl.axes.AxesSubplot or list of</code>, default:                   <code>None</code> )           \u2013            <p>Specify matplotlib.axes.Axes to check for labeling only outer. Default use all of current figure.</p> </li> </ul> Source code in <code>src/prettypyplot/subplots.py</code> <pre><code>def label_outer(axs=None):\n    \"\"\"Only show outer labels and tick labels.\n\n    This checks for outest visible axes only. Works only with single Gridspec.\n\n    Parameters\n    ----------\n    axs : mpl.axes.AxesSubplot or list of\n        Specify [matplotlib.axes.Axes][] to check for labeling only outer.\n        Default use all of current figure.\n\n    \"\"\"\n    # check for single axes\n    if axs is not None:\n        axs = tools.get_axes(axs)\n        if not all((_is_subplot_axes(arg) for arg in axs)):\n            raise TypeError(\n                'axs needs to be of type matplotlib.axes.AxesSuplot.',\n            )\n    else:\n        axs = [ax for ax in plt.gcf().get_axes() if _is_subplot_axes(ax)]\n\n    for ax in axs:\n        ss = ax.get_subplotspec()\n        if hasattr(ss, 'is_last_row'):  # pragma: no cover # noqa: WPS421\n            # for mpl &gt;= 3.4\n            lastrow = ss.is_last_row()\n            firstcol = ss.is_first_col()\n        elif hasattr(ax, 'is_last_row'):  # pragma: no cover # noqa: WPS421\n            lastrow = ax.is_last_row()\n            firstcol = ax.is_first_col()\n        else:\n            raise TypeError(f'{ax!r} is not a valid axes.')\n\n        # check if axes below, left is hidden\n        left_empty, bottom_empty = _is_outer_hidden(axs, ax)\n        _label_outer(ax, lastrow or bottom_empty, firstcol or left_empty)\n</code></pre>"},{"location":"reference/#prettypyplot.subplot_labels","title":"<code>subplot_labels(*, fig=None, xlabel=None, ylabel=None)</code>","text":"<p>Add global labels for subplots.</p> <p>This method adds shared x- and y-labels for a grid of subplots. These can be created by, e.g. <code>fig, axs = plt.subplots(...)</code>.</p> <p>Parameters:</p> <ul> <li> <code>fig</code>               (<code>matplotlib figure</code>, default:                   <code>None</code> )           \u2013            <p>If <code>None</code> the current figure will be used instead.</p> </li> <li> <code>xlabel</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>String of x label.</p> </li> <li> <code>ylabel</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>String of y label.</p> </li> </ul> Source code in <code>src/prettypyplot/subplots.py</code> <pre><code>def subplot_labels(*, fig=None, xlabel=None, ylabel=None):\n    \"\"\"Add global labels for subplots.\n\n    This method adds shared x- and y-labels for a grid of subplots. These can\n    be created by, e.g. `fig, axs = plt.subplots(...)`.\n\n    Parameters\n    ----------\n    fig : matplotlib figure, optional\n        If `None` the current figure will be used instead.\n    xlabel : str, optional\n        String of x label.\n    ylabel : str, optional\n        String of y label.\n\n    \"\"\"\n    # if no label passed, nothing to do\n    if xlabel is None and ylabel is None:\n        return\n\n    # get active axes to restore it later on\n    ca = plt.gca()\n\n    if fig is None:\n        fig = plt.gcf()\n\n    _subplot_labels(fig, xlabel, ylabel)\n\n    # reset current axes\n    plt.sca(ca)\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>prettypyplot<ul> <li>colors</li> <li>pyplot</li> <li>style</li> <li>subplots</li> <li>texts</li> <li>tools</li> </ul> </li> </ul>"},{"location":"reference/colors/","title":"colors","text":"<p>Set-up matplotlib environment.</p>"},{"location":"reference/colors/#prettypyplot.colors.GrayTones","title":"<code>GrayTones</code>","text":"<p>               Bases: <code>namedtuple('GrayTones', 'dark light')</code></p> <p>Class for holding light and dark gray tone.</p>"},{"location":"reference/colors/#prettypyplot.colors.load_cmaps","title":"<code>load_cmaps()</code>","text":"<p>Load and include custom colormaps to matplotlib.</p> <p>Add sequential colormaps <code>pastel5</code>, <code>pastel6</code>, <code>cbf4</code>, <code>cbf5</code>, <code>cbf8</code>, and <code>ufcd</code> as an corporate design. Except of <code>ufcd</code> all palettes should be 'color-blind-friendly'.</p> <p>Add continuous colormaps macaw, Turbo. The Copyright of those are given on top of the data.</p> <p>See</p> <p>Choosing an cmaps.</p> Source code in <code>src/prettypyplot/colors.py</code> <pre><code>def load_cmaps():\n    \"\"\"Load and include custom colormaps to matplotlib.\n\n    Add sequential colormaps `pastel5`, `pastel6`, `cbf4`, `cbf5`, `cbf8`,\n    and `ufcd` as an corporate design. Except of `ufcd` all palettes should be\n    'color-blind-friendly'.\n\n    Add continuous colormaps macaw, Turbo. The Copyright of those are given on\n    top of the data.\n\n    !!! see\n        Choosing an [cmaps](../../gallery/cmaps).\n\n    \"\"\"\n    colormaps = (\n        _argon(),\n        _pastel5(),\n        _pastel6(),\n        _cbf4(),\n        _cbf5(),\n        _cbf8(),\n        _gdv_rag(),\n        _gdv_rag_cvd(),\n        _gdv_palette(),\n        _gdv_6a(),\n        _gdv_5a(),\n        _gdv_4a(),\n        _gdv_4b(),\n        _gdv_3a(),\n        _gdv_3b(),\n        _gdv_2a(),\n        _gdv_2b(),\n        _gdv_s1(),\n        _gdv_s2(),\n        _gdv_s3(),\n        _gdv_m1(),\n        _gdv_m2(),\n        _gdv_m3(),\n        _gdv_d1(),\n        _gdv_d2(),\n        _gdv_d3(),\n        _gdv_d4(),\n        _gdv_mars(),\n        _gdv_moon(),\n        _pastel_autumn(),\n        _pastel_rainbow(),\n        _pastel_spring(),\n        _paula(),\n        _paula2(),\n        _paula_cbf(),\n        _paula_lime(),\n        _summertimes(),\n        _tol_bright(),\n        _tol_high_contrast(),\n        _tol_light(),\n        _tol_medium_contrast(),\n        _tol_muted(),\n        _tol_vibrant(),\n        _ufcd(),\n        _turbo(),\n        _macaw(),\n        _bownair(),\n    )\n    # register own continuous and discrete cmaps\n    for colormap in colormaps:\n        # add cmap and reverse cmap\n        for cmap in (colormap, colormap.reversed()):\n            try:\n                _get_cmap(cmap.name)\n            except ValueError:\n                _register_cmap(cmap=cmap)\n</code></pre>"},{"location":"reference/colors/#prettypyplot.colors.load_colors","title":"<code>load_colors()</code>","text":"<p>Load and include custom colors to matplotlib.</p> <p>Add colors of <code>pastel5</code> which can be accessed via <code>pplt:blue</code>, <code>pplt:red</code>, <code>pplt:green</code>, <code>pplt:orange</code>, <code>pplt:lightblue</code>, <code>pplt:gray</code> and <code>pplt:lightgray</code>. Further, the current colors will be added <code>pplt:axes</code>, <code>pplt:text</code>, <code>pplt:grid</code>.</p> <p>See</p> <p>Choosing an cmaps.</p> Source code in <code>src/prettypyplot/colors.py</code> <pre><code>def load_colors():\n    \"\"\"Load and include custom colors to matplotlib.\n\n    Add colors of `pastel5` which can be accessed via `pplt:blue`, `pplt:red`,\n    `pplt:green`, `pplt:orange`, `pplt:lightblue`, `pplt:gray` and\n    `pplt:lightgray`. Further, the current colors will be added `pplt:axes`,\n    `pplt:text`, `pplt:grid`.\n\n    !!! see\n        Choosing an [cmaps](../../gallery/cmaps).\n\n    \"\"\"\n    # register own colors\n    pplt_colors = {\n        'pplt:blue': _pastel5().colors[0],\n        'pplt:red': _pastel5().colors[1],\n        'pplt:green': _pastel5().colors[2],\n        'pplt:orange': _pastel5().colors[3],\n        'pplt:lightblue': _pastel5().colors[4],\n        'pplt:gray': default_grays.dark,\n        'pplt:grey': default_grays.dark,\n        'pplt:lightgray': default_grays.light,\n        'pplt:lightgrey': default_grays.light,\n        'pplt:axes': plt.rcParams['axes.edgecolor'],\n        'pplt:text': plt.rcParams['text.color'],\n        'pplt:grid': plt.rcParams['grid.color'],\n    }\n    clr._colors_full_map.update(pplt_colors)\n</code></pre>"},{"location":"reference/colors/#prettypyplot.colors.categorical_cmap","title":"<code>categorical_cmap(nc, nsc, *, cmap=None, return_colors=False)</code>","text":"<p>Generate categorical colors of given cmap.</p> <p>Exract from a predefined colormap colors and generate for each the desired number of shades.</p> <p>Parameters:</p> <ul> <li> <code>nc</code>               (<code>int</code>)           \u2013            <p>Number of colors</p> </li> <li> <code>nsc</code>               (<code>int</code>)           \u2013            <p>Number of shades per colors</p> </li> <li> <code>cmap</code>               (<code>`matplotlib.colors.Colormap` or str</code>, default:                   <code>None</code> )           \u2013            <p>Matplotlib colormap to take colors from. The default is the active color cycle.</p> </li> <li> <code>return_colors</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return an array of rgb colors. Each color together with its shades are in an own row.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>scolors</code> (              <code>`matplotlib.colors.Colormap` or np.ndarray</code> )          \u2013            <p>Return discrete colormap. If return_colors, a 2d representation will be returned instead.</p> </li> </ul> Source code in <code>src/prettypyplot/colors.py</code> <pre><code>def categorical_cmap(nc, nsc, *, cmap=None, return_colors=False):\n    \"\"\"Generate categorical colors of given cmap.\n\n    Exract from a predefined colormap colors and generate for each the desired\n    number of shades.\n\n    Parameters\n    ----------\n    nc : int\n        Number of colors\n    nsc : int\n        Number of shades per colors\n    cmap : `matplotlib.colors.Colormap` or str, optional\n        Matplotlib colormap to take colors from. The default is the active\n        color cycle.\n    return_colors : bool, optional\n        Return an array of rgb colors. Each color together with its shades are\n        in an own row.\n\n    Returns\n    -------\n    scolors : `matplotlib.colors.Colormap` or np.ndarray\n        Return discrete colormap. If return_colors, a 2d representation will\n        be returned instead.\n\n    \"\"\"\n    # check correct data type\n    _is_number_in_range(\n        nc,\n        name='nc',\n        dtype=int,\n        low=1,\n        high=np.iinfo(int).max,\n    )\n    _is_number_in_range(\n        nsc,\n        name='nsc',\n        dtype=int,\n        low=1,\n        high=np.iinfo(int).max,\n    )\n    nc, nsc = int(nc), int(nsc)\n\n    # get cmap\n    if cmap is not None:\n        cmap = plt.get_cmap(cmap)\n    else:\n        cmap = clr.ListedColormap(\n            plt.rcParams['axes.prop_cycle'].by_key()['color'],\n        )\n    if nc &gt; cmap.N:\n        raise ValueError('Too many categories for colormap.')\n\n    # extract colors from cmap\n    if isinstance(cmap, clr.LinearSegmentedColormap):\n        colors = cmap(np.linspace(0, 1, nc))\n    elif isinstance(cmap, clr.ListedColormap):\n        colors = cmap(np.arange(nc, dtype=int))\n\n    # get shades of colors\n    scolors = np.empty((nc, nsc, 3))\n    for idx, color in enumerate(colors):\n        scolors[idx] = categorical_color(nsc, color)\n\n    if return_colors:\n        return scolors\n    return clr.ListedColormap(np.concatenate(scolors))\n</code></pre>"},{"location":"reference/colors/#prettypyplot.colors.categorical_color","title":"<code>categorical_color(nsc, color, *, return_hex=False)</code>","text":"<p>Generate categorical shades of given colors.</p> <p>Generate for each provided color the number of specified shades. The shaded colors are interpolated linearly in HSV colorspace. This function is based on following post: https://stackoverflow.com/a/47232942</p> <p>Parameters:</p> <ul> <li> <code>nsc</code>               (<code>int</code>)           \u2013            <p>Number of shades per color.</p> </li> <li> <code>color</code>               (<code>RGB color or matplotlib predefined color</code>)           \u2013            <p>Color used for generating shades.</p> </li> <li> <code>return_hex</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return colors in hex format instead of rgb.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>colors_rgb</code> (              <code>list of RGB colors</code> )          \u2013            <p>A list containing shaded colors. Where the list is sorted from the original color at the beginning to the most shaded one at the end. The default color encoding is rgb and hex if specified.</p> </li> </ul> Source code in <code>src/prettypyplot/colors.py</code> <pre><code>def categorical_color(nsc, color, *, return_hex=False):\n    \"\"\"Generate categorical shades of given colors.\n\n    Generate for each provided color the number of specified shades. The shaded\n    colors are interpolated linearly in HSV colorspace. This function is based\n    on following post: https://stackoverflow.com/a/47232942\n\n    Parameters\n    ----------\n    nsc : int\n        Number of shades per color.\n    color : RGB color or matplotlib predefined color\n        Color used for generating shades.\n    return_hex : bool, optional\n        Return colors in hex format instead of rgb.\n\n    Returns\n    -------\n    colors_rgb : list of RGB colors\n        A list containing shaded colors. Where the list is sorted from the\n        original color at the beginning to the most shaded one at the end.\n        The default color encoding is rgb and hex if specified.\n\n    \"\"\"\n    # check correct data type\n    color = clr.to_rgb(color)\n    _is_number_in_range(\n        nsc,\n        name='nsc',\n        dtype=int,\n        low=1,\n        high=np.iinfo(int).max,\n    )\n    nsc = int(nsc)\n\n    # genrate shades of colors\n    color_hsv = clr.rgb_to_hsv(color)\n    colors_hsv = np.tile(color_hsv, nsc).reshape(nsc, 3)\n    colors_hsv[:, 1] = np.linspace(color_hsv[1], 1 / 4, nsc)\n    colors_hsv[:, 2] = np.linspace(color_hsv[2], 1, nsc)\n    colors_rgb = clr.hsv_to_rgb(colors_hsv)\n\n    # check if color is greyscale value, need to fix arbitrary hue value of 0\n    if is_greyshade(color):\n        colors_rgb[:, 0] = colors_rgb[:, 1]\n\n    if return_hex:\n        return [clr.to_hex(color) for color in colors_rgb]\n    return colors_rgb\n</code></pre>"},{"location":"reference/colors/#prettypyplot.colors.text_color","title":"<code>text_color(bgcolor, colors=('#000000', '#ffffff'))</code>","text":"<p>Select textcolor with maximal contrast on background.</p> <p>All parameters needs to be colors accepted by matplotlib, see matplotlib.colors. The formulas are taken from W3C WCAG 2.1 (Web Content Accessibility Guidelines).</p> <p>Parameters:</p> <ul> <li> <code>bgcolor</code>               (<code>matplotlib color</code>)           \u2013            <p>Background color to which the contrast is maximized.</p> </li> <li> <code>colors</code>               (<code>list of matplotlib colors</code>, default:                   <code>('#000000', '#ffffff')</code> )           \u2013            <p>Selection of textcolors to choose from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>color</code> (              <code>matplotlib color</code> )          \u2013            <p>Color of colors which has the highest contrast on the given bgcolor.</p> </li> </ul> Source code in <code>src/prettypyplot/colors.py</code> <pre><code>def text_color(bgcolor, colors=('#000000', '#ffffff')):\n    \"\"\"Select textcolor with maximal contrast on background.\n\n    All parameters needs to be colors accepted by matplotlib, see\n    [matplotlib.colors](https://matplotlib.org/api/colors_api.html).\n    The formulas are taken from W3C [WCAG 2.1](https://www.w3.org/TR/WCAG21)\n    (Web Content Accessibility Guidelines).\n\n    Parameters\n    ----------\n    bgcolor : matplotlib color\n        Background color to which the contrast is maximized.\n    colors : list of matplotlib colors, optional\n        Selection of textcolors to choose from.\n\n    Returns\n    -------\n    color : matplotlib color\n        Color of colors which has the highest contrast on the given bgcolor.\n\n    \"\"\"\n    # check input by casting to matplotlib colors\n    bgcolor = clr.to_rgb(bgcolor)\n    colors_rgb = [clr.to_rgb(color) for color in colors]\n\n    # calculate the (luminances)\n    bgL = _relative_luminance(bgcolor)\n    Ls = [_relative_luminance(color) for color in colors_rgb]\n\n    # calculate contrast between bgcolor and all colors\n    contrast = [_contrast(bgL, Luminance) for Luminance in Ls]\n\n    # return color corresponding to greatest contrast\n    idx = contrast.index(max(contrast))\n    return colors[idx]\n</code></pre>"},{"location":"reference/colors/#prettypyplot.colors.is_greyshade","title":"<code>is_greyshade(color)</code>","text":"<p>Check if color is a greyscale value including bw.</p> Source code in <code>src/prettypyplot/colors.py</code> <pre><code>def is_greyshade(color):\n    \"\"\"Check if color is a greyscale value including bw.\"\"\"\n    # check if color is greyscale value, need to fix arbitrary hue value\n    color = clr.to_rgb(color)\n    if np.min(color) == np.max(color):\n        return True\n    return False\n</code></pre>"},{"location":"reference/pyplot/","title":"pyplot","text":"<p>Wrapper for matplotlib plotting functions.</p>"},{"location":"reference/pyplot/#prettypyplot.pyplot.imshow","title":"<code>imshow(*args, ax=None, **kwargs)</code>","text":"<p>Display an image, i.e. data on a 2D regular raster.</p> <p>This is a wrapper of pyplot.imshow(). In contrast to the original function the default value of <code>zorder</code> is increased to <code>1</code>.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>, default:                   <code>None</code> )           \u2013            <p>matplotlib.axes.Axes to plot in.</p> </li> <li> <code>args</code>           \u2013            <p>See matplotlib.pyplot.imshow.</p> </li> <li> <code>kwargs</code>           \u2013            <p>See matplotlib.pyplot.imshow.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>im</code> (              <code>AxesImage</code> )          \u2013            <p>Reference to plotted image matplotlib.image.AxesImage</p> </li> </ul> Source code in <code>src/prettypyplot/pyplot.py</code> <pre><code>def imshow(*args, ax=None, **kwargs):\n    \"\"\"Display an image, i.e. data on a 2D regular raster.\n\n    This is a wrapper of pyplot.imshow(). In contrast to the original function\n    the default value of `zorder` is increased to `1`.\n\n    Parameters\n    ----------\n    ax : Axes, optional\n        [matplotlib.axes.Axes][] to plot in.\n    args, kwargs\n        See [matplotlib.pyplot.imshow][].\n\n    Returns\n    -------\n    im : AxesImage\n        Reference to plotted image [matplotlib.image.AxesImage][]\n\n    \"\"\"\n    args, ax = tools.parse_axes(*args, ax=ax)\n\n    if 'zorder' not in kwargs:\n        kwargs['zorder'] = 1\n\n    # plot\n    return ax.imshow(*args, **kwargs)\n</code></pre>"},{"location":"reference/pyplot/#prettypyplot.pyplot.plot","title":"<code>plot(*args, ax=None, **kwargs)</code>","text":"<p>Plot simple lineplot.</p> <p>Wrapping pyplot.plot() to adjust to style. For more information on the arguments see in matplotlib documentation. If <code>STYLE='minimal'</code>, spines will be limited to plotting range.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>, default:                   <code>None</code> )           \u2013            <p>matplotlib.axes.Axes to plot in.</p> </li> <li> <code>args</code>           \u2013            <p>See matplotlib.pyplot.plot.</p> </li> <li> <code>kwargs</code>           \u2013            <p>See matplotlib.pyplot.plot.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>lines</code> (              <code>list of Line2D</code> )          \u2013            <p>A list of matplotlib.lines.Line2D representing the plotted data.</p> </li> </ul> Source code in <code>src/prettypyplot/pyplot.py</code> <pre><code>def plot(*args, ax=None, **kwargs):\n    \"\"\"Plot simple lineplot.\n\n    Wrapping pyplot.plot() to adjust to style. For more information on the\n    arguments see in matplotlib documentation.\n    If `STYLE='minimal'`, spines will be limited to plotting range.\n\n    Parameters\n    ----------\n    ax : Axes\n        [matplotlib.axes.Axes][] to plot in.\n    args, kwargs\n        See [matplotlib.pyplot.plot][].\n\n    Returns\n    -------\n    lines : list of Line2D\n        A list of [matplotlib.lines.Line2D][] representing the plotted data.\n\n    \"\"\"\n    # parse axes\n    args, ax = tools.parse_axes(*args, ax=ax)\n\n    # plot\n    lines = ax.plot(*args, **kwargs)\n\n    if _pplt.STYLE == Style.MINIMAL:\n        _set_spine_bounds(ax)\n\n    return lines\n</code></pre>"},{"location":"reference/pyplot/#prettypyplot.pyplot.savefig","title":"<code>savefig(fname, reference_ax=None, use_canvas_size=True, **kwargs)</code>","text":"<p>Save figure as png and pdf.</p> <p>This methods corrects figsize for poster/beamer mode.</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>Output filename. If no file ending, pdf will be used.</p> </li> <li> <code>reference_ax</code>               (<code>Axes</code>, default:                   <code>None</code> )           \u2013            <p>matplotlib.axes.Axes used for resizing. If <code>None</code> first axes of figure is used.</p> </li> <li> <code>use_canvas_size</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True the specified figsize will be used as canvas size.</p> </li> <li> <code>kwargs</code>           \u2013            <p>See matplotlib.pyplot.savefig.</p> </li> </ul> Source code in <code>src/prettypyplot/pyplot.py</code> <pre><code>def savefig(fname, reference_ax=None, use_canvas_size=True, **kwargs):\n    \"\"\"Save figure as png and pdf.\n\n    This methods corrects figsize for poster/beamer mode.\n\n    Parameters\n    ----------\n    fname : str\n        Output filename. If no file ending, pdf will be used.\n    reference_ax : Axes, optional\n        [matplotlib.axes.Axes][] used for resizing. If `None` first axes of\n        figure is used.\n    use_canvas_size : bool, optional\n        If True the specified figsize will be used as canvas size.\n    kwargs\n        See [matplotlib.pyplot.savefig][].\n\n    \"\"\"\n    set_figsize = _resize_canvas(\n        reference_ax=reference_ax,\n        use_canvas_size=use_canvas_size,\n    )\n\n    # save as pdf if not specified\n    if 'format' not in kwargs:\n        if path.splitext(fname)[1][1:] == '':\n            fname = '{0}.pdf'.format(fname)\n\n    # save fig\n    plt.savefig(fname, **kwargs)\n\n    # reset figsize, if user calls this function multiple times on same figure\n    fig = plt.gcf()\n    fig.set_size_inches(set_figsize)\n</code></pre>"},{"location":"reference/pyplot/#prettypyplot.pyplot.show","title":"<code>show(reference_ax=None, use_canvas_size=True, **kwargs)</code>","text":"<p>Show figure and rescale similar to pplt.savefig.</p> <p>Parameters:</p> <ul> <li> <code>reference_ax</code>               (<code>Axes</code>, default:                   <code>None</code> )           \u2013            <p>matplotlib.axes.Axes used for resizing. If <code>None</code> first axes of figure is used.</p> </li> <li> <code>use_canvas_size</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True the specified figsize will be used as canvas size.</p> </li> <li> <code>kwargs</code>           \u2013            <p>See matplotlib.pyplot.show.</p> </li> </ul> Source code in <code>src/prettypyplot/pyplot.py</code> <pre><code>def show(reference_ax=None, use_canvas_size=True, **kwargs):\n    \"\"\"Show figure and rescale similar to pplt.savefig.\n\n    Parameters\n    ----------\n    reference_ax : Axes, optional\n        [matplotlib.axes.Axes][] used for resizing. If `None` first axes of\n        figure is used.\n    use_canvas_size : bool, optional\n        If True the specified figsize will be used as canvas size.\n    kwargs\n        See [matplotlib.pyplot.show][].\n\n    \"\"\"\n    set_figsize = _resize_canvas(\n        reference_ax=reference_ax,\n        use_canvas_size=use_canvas_size,\n    )\n\n    # save fig\n    plt.show(**kwargs)\n\n    # reset figsize, if user calls this function multiple times on same figure\n    fig = plt.gcf()\n    fig.set_size_inches(set_figsize)\n</code></pre>"},{"location":"reference/pyplot/#prettypyplot.pyplot.legend","title":"<code>legend(*args, outside=False, ax=None, axs=None, **kwargs)</code>","text":"<p>Generate a nice legend.</p> <p>This is a wrapper of pyplot.legend(). Take a look there for the default arguments and options. The ticks and labels are moved to the opposite side. For <code>top</code> and <code>bottom</code> the default value of columns is set to the number of labels, for all other options to 1. In case of many labels this parameter needs to be adjusted.</p> <p>Note</p> <p>Use handles and labels from *args if provided</p> <p>Example</p> <p>Checkout the gallery for an example.</p> <p>Parameters:</p> <ul> <li> <code>outside</code>               (<code>str or bool</code>, default:                   <code>False</code> )           \u2013            <p>False, 'top', 'right', 'bottom' or 'left'.</p> </li> <li> <code>axs</code>               (<code>list of Axes</code>, default:                   <code>None</code> )           \u2013            <p>List of matplotlib.axes.Axes which are used for extracting all labels.</p> </li> <li> <code>ax</code>               (<code>Axes</code>, default:                   <code>None</code> )           \u2013            <p>matplotlib.axes.Axes which is used for placing legend.</p> </li> <li> <code>args</code>           \u2013            <p>See matplotlib.pyplot.legend.</p> </li> <li> <code>kwargs</code>           \u2013            <p>See matplotlib.pyplot.legend.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>leg</code> (              <code>Legend</code> )          \u2013            <p>[matplotlib.legend.Legend] legend handle.</p> </li> </ul> Source code in <code>src/prettypyplot/pyplot.py</code> <pre><code>def legend(*args, outside=False, ax=None, axs=None, **kwargs):\n    \"\"\"Generate a nice legend.\n\n    This is a wrapper of pyplot.legend(). Take a look there for the default\n    arguments and options. The ticks and labels are moved to the opposite side.\n    For `top` and `bottom` the default value of columns is set to the number of\n    labels, for all other options to 1. In case of many labels this parameter\n    needs to be adjusted.\n\n    !!! note\n        Use handles and labels from *args if provided\n\n    !!! example\n        Checkout the gallery for [an example](../../gallery/legend).\n\n    Parameters\n    ----------\n    outside : str or bool\n        False, 'top', 'right', 'bottom' or 'left'.\n    axs : list of Axes\n        List of [matplotlib.axes.Axes][] which are used for extracting all\n        labels.\n    ax : Axes\n        [matplotlib.axes.Axes][] which is used for placing legend.\n    args, kwargs\n        See [matplotlib.pyplot.legend][].\n\n    Returns\n    -------\n    leg : Legend\n        [matplotlib.legend.Legend] legend handle.\n\n    \"\"\"\n    default_kwargs = _legend_default_kwargs()\n    if outside not in {False, *default_kwargs}:\n        raise ValueError(\n            'Use for outside one of [False, {0}]'.format(\n                ', '.join(['\"{0}\"'.format(dr) for dr in default_kwargs]),\n            ),\n        )\n\n    # parse axes\n    args, ax = tools.parse_axes(*args, ax=ax)\n\n    # parse axs\n    if axs is None:\n        axs = [ax]\n    else:\n        axs = tools.get_axes(axs)\n\n    # shift axis to opposite side.\n    if outside:\n        activate_axis(_opposite_side(outside))\n\n    # set anchor, mode and location\n    kwargs = {**default_kwargs.get(outside, {}), **kwargs}\n\n    # get handles and labels of selected axes\n    handles, labels = mlegend._get_legend_handles_labels(axs)\n\n    # set number of ncol to the number of items\n    if outside in {'top', 'bottom'}:\n        kwargs.setdefault('ncol', len(labels))\n\n    # generate legend\n    leg = ax.legend(handles, labels, *args, **kwargs)\n    if _pplt.STYLE == Style.MINIMAL:\n        leg.get_frame().set_linewidth(0.0)\n    elif _pplt.STYLE == Style.DEFAULT:\n        leg.get_frame().set_linewidth(plt.rcParams['axes.linewidth'])\n\n    # shift title to the left if on top or bottom\n    if outside in {'top', 'bottom'}:\n        _shift_legend_title(leg)\n\n    return leg\n</code></pre>"},{"location":"reference/pyplot/#prettypyplot.pyplot.activate_axis","title":"<code>activate_axis(position, ax=None)</code>","text":"<p>Shift the specified axis to the opposite side.</p> <p>Parameters:</p> <ul> <li> <code>position</code>               (<code>str or list of str</code>)           \u2013            <p>Specify axis to flip, one of <code>['left', 'right', 'top', 'bottom']</code>.</p> </li> <li> <code>ax</code>               (<code>Axes</code>, default:                   <code>None</code> )           \u2013            <p>matplotlib.axes.Axes axes to flip axis.</p> </li> </ul> Source code in <code>src/prettypyplot/pyplot.py</code> <pre><code>def activate_axis(position, ax=None):\n    \"\"\"Shift the specified axis to the opposite side.\n\n    Parameters\n    ----------\n    position : str or list of str\n        Specify axis to flip, one of `['left', 'right', 'top', 'bottom']`.\n    ax : Axes\n        [matplotlib.axes.Axes][] axes to flip axis.\n\n    \"\"\"\n    # get axes\n    ax = tools.gca(ax)\n\n    # convert string to list of strings\n    if isinstance(position, str):\n        position = [position]\n\n    # allowed values\n    positions = {'bottom', 'top', 'left', 'right'}\n\n    # move axes ticks and labels to opposite side of position\n    for pos in position:\n        if pos not in positions:\n            raise ValueError(\n                '{0:!r} is not a valid value for {1}; supported values are {2}'.format(\n                    pos, 'position', ', '.join(positions)\n                )\n            )\n\n        if pos in {'bottom', 'top'}:\n            axis = ax.xaxis\n        elif pos in {'left', 'right'}:\n            axis = ax.yaxis\n        axis.set_ticks_position(pos)\n        axis.set_label_position(pos)\n</code></pre>"},{"location":"reference/pyplot/#prettypyplot.pyplot.colorbar","title":"<code>colorbar(im, width='7%', pad='0%', position='right', label=None, **kwargs)</code>","text":"<p>Generate colorbar of same height as image.</p> <p>Wrapper around pyplot.colorbar which corrects the height.</p> <p>Example</p> <p>Checkout the gallery for an example.</p> <p>Parameters:</p> <ul> <li> <code>im</code>               (<code>AxesImage</code>)           \u2013            <p>Specify the object the colorbar belongs to, e.g. the return value of matplotlib.pyplot.imshow.</p> </li> <li> <code>width</code>               (<code>str or float</code>, default:                   <code>'7%'</code> )           \u2013            <p>The width between figure and colorbar stated relative as string ending with '%' or absolute value in inches.</p> </li> <li> <code>pad</code>               (<code>str or float</code>, default:                   <code>'0%'</code> )           \u2013            <p>The width between figure and colorbar stated relative as string ending with '%' or absolute value in inches.</p> </li> <li> <code>position</code>               (<code>str</code>, default:                   <code>'right'</code> )           \u2013            <p>Specify the position relative to the image where the colorbar is plotted, choose one of ['left', 'top', 'right', 'bottom']</p> </li> <li> <code>label</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Specify the colorbar label.</p> </li> <li> <code>kwargs</code>           \u2013            <p>Colorbar properties of, matplotlib.pyplot.colorbar.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>colorbar</code> (              <code>Colorbar</code> )          \u2013            <p>matplotlib.colorbar.Colorbar instance.</p> </li> </ul> Source code in <code>src/prettypyplot/pyplot.py</code> <pre><code>def colorbar(im, width='7%', pad='0%', position='right', label=None, **kwargs):\n    \"\"\"Generate colorbar of same height as image.\n\n    Wrapper around pyplot.colorbar which corrects the height.\n\n    !!! example\n        Checkout the gallery for [an example](../../gallery/colorbar).\n\n    Parameters\n    ----------\n    im : matplotlib.axes.AxesImage\n        Specify the object the colorbar belongs to, e.g. the return value of\n        [matplotlib.pyplot.imshow][].\n    width : str or float, optional\n        The width between figure and colorbar stated relative as string ending\n        with '%' or absolute value in inches.\n    pad : str or float, optional\n        The width between figure and colorbar stated relative as string ending\n        with '%' or absolute value in inches.\n    position : str, optional\n        Specify the position relative to the image where the colorbar is\n        plotted, choose one of ['left', 'top', 'right', 'bottom']\n    label : str, optional\n        Specify the colorbar label.\n    kwargs\n        Colorbar properties of, [matplotlib.pyplot.colorbar][].\n\n    Returns\n    -------\n    colorbar : Colorbar\n        [matplotlib.colorbar.Colorbar][] instance.\n\n    \"\"\"\n    orientation = 'vertical'\n    if position in {'top', 'bottom'}:\n        orientation = 'horizontal'\n\n    # get axes\n    if hasattr(im, 'axes'):\n        ax = im.axes\n    elif hasattr(im, 'ax'):\n        ax = im.ax\n    else:\n        ax = plt.gca()\n\n    # generate divider\n    divider = mpl_axes_grid1.make_axes_locatable(ax)\n    cax = divider.append_axes(position, width, pad=pad)\n\n    cbar = plt.colorbar(im, cax=cax, orientation=orientation, **kwargs)\n    if label:\n        cbar.set_label(label)\n\n    # set ticks and label of ticks to the outside\n    activate_axis(position, ax=cax)\n    # set the axis opposite to the colorbar to active\n    activate_axis(_opposite_side(position), ax=ax)\n\n    # invert width and pad\n    pad_inv, width_inv = tools.invert_sign(pad), tools.invert_sign(width)\n    cax_reset = divider.append_axes(position, width_inv, pad=pad_inv)\n    cax_reset.set_visible(False)\n\n    return cbar\n</code></pre>"},{"location":"reference/pyplot/#prettypyplot.pyplot.grid","title":"<code>grid(*args, ax=None, **kwargs)</code>","text":"<p>Generate grid.</p> <p>This function will add a major and minor grid in case of STYLE='default', a major grid in case of 'none' and otherwise nothing.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>, default:                   <code>None</code> )           \u2013            <p>[matplotlib.axes.Axes] axes to plot grid.</p> </li> <li> <code>args</code>           \u2013            <p>See matplotlib.pyplot.grid.</p> </li> <li> <code>kwargs</code>           \u2013            <p>See matplotlib.pyplot.grid.</p> </li> </ul> Source code in <code>src/prettypyplot/pyplot.py</code> <pre><code>def grid(*args, ax=None, **kwargs):\n    \"\"\"Generate grid.\n\n    This function will add a major and minor grid in case of STYLE='default',\n    a major grid in case of 'none' and otherwise nothing.\n\n    Parameters\n    ----------\n    ax : Axes\n        [matplotlib.axes.Axes] axes to plot grid.\n    args, kwargs\n        See [matplotlib.pyplot.grid][].\n\n    \"\"\"\n    # parse axes\n    args, ax = tools.parse_axes(*args, ax=ax)\n\n    if 'visible' in kwargs:  # mpl &gt;= 3.6\n        show_grid = kwargs['visible']\n    elif 'b' in kwargs:  # mpl &lt;=3.5\n        show_grid = kwargs['b']\n    else:\n        boolargs = [arg for arg in args if isinstance(arg, bool)]\n        show_grid = boolargs[0] if len(boolargs) &gt;= 1 else True\n\n    if _pplt.STYLE != Style.MINIMAL and show_grid:\n        gr_maj = ax.grid(show_grid, which='major', linestyle='--', **kwargs)\n        gr_min = ax.grid(show_grid, which='minor', linestyle='dotted', **kwargs)\n    else:\n        gr_maj = ax.grid(False, which='major')\n        gr_min = ax.grid(False, which='minor')\n\n    ax.set_axisbelow(True)\n    return (gr_maj, gr_min)\n</code></pre>"},{"location":"reference/style/","title":"style","text":"<p>Set-up matplotlib environment.</p>"},{"location":"reference/style/#prettypyplot.style.Style","title":"<code>Style</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for all styles defined in pplt.</p>"},{"location":"reference/style/#prettypyplot.style.Style.keys_list","title":"<code>keys_list()</code>  <code>classmethod</code>","text":"<p>Return list of available Style names.</p> Source code in <code>src/prettypyplot/style.py</code> <pre><code>@classmethod\ndef keys_list(cls):\n    \"\"\"Return list of available Style names.\"\"\"\n    return list(cls.__members__.keys())\n</code></pre>"},{"location":"reference/style/#prettypyplot.style.Mode","title":"<code>Mode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for all modes defined in pplt.</p>"},{"location":"reference/style/#prettypyplot.style.Mode.keys_list","title":"<code>keys_list()</code>  <code>classmethod</code>","text":"<p>Return list of available Mode names.</p> Source code in <code>src/prettypyplot/style.py</code> <pre><code>@classmethod\ndef keys_list(cls):\n    \"\"\"Return list of available Mode names.\"\"\"\n    return list(cls.__members__.keys())\n</code></pre>"},{"location":"reference/style/#prettypyplot.style.update_style","title":"<code>update_style(interactive=None, colors=None, cmap=None, ncs=None, figsize=None, figratio=None, mode=None, style=None, ipython=None, true_black=None, latex=None, sf=None)</code>","text":"<p>Update alternative matplotlib style.</p> <p>This function updates specified parameters of <code>use_style</code> without changing other.</p> <p>Parameters:</p> <ul> <li> <code>interactive</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Set interactive mode.</p> </li> <li> <code>colors</code>               (<code>string</code>, default:                   <code>None</code> )           \u2013            <p>Set the default color cycler from continuous or discrete maps. Use any of matplotlibs defaults or specified in the colors submodule.</p> </li> <li> <code>cmap</code>               (<code>string</code>, default:                   <code>None</code> )           \u2013            <p>Set the default colormap.</p> </li> <li> <code>ncs</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of colors if continuous cmap is selected.</p> </li> <li> <code>figsize</code>               (<code>int or int tuple</code>, default:                   <code>None</code> )           \u2013            <p>Give size of default figure in inches, either as tuple (x, y) or a single float for the x-axis. The y-axis will be determined by figratio.</p> </li> <li> <code>figratio</code>               (<code>str or float</code>, default:                   <code>None</code> )           \u2013            <p>Set ratio of figsize x:y to 1:1/'option', where 'option' is one of <code>['sqrt(2)', 'golden', 'sqrt(3)']</code> or any number. Golden stands for the golden ratio (1.618). This option is ignored if figsize is used with tuple.</p> </li> <li> <code>mode</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>One of the following modes: <code>'default'</code>: use matplotlib defaults <code>'beamer'</code>: extra large fontsize <code>'print'</code>: default sizes <code>'poster'</code>: for Din A0 posters</p> </li> <li> <code>style</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>One of the following styles: <code>'default'</code>: enables grid and upper and right spines <code>'minimal'</code>: removes all unneeded lines <code>'none'</code>: no changes to style</p> </li> <li> <code>ipython</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Deactivate high-res in jpg/png for compatibility with IPyhton, e.g. jupyter notebook/lab.</p> </li> <li> <code>true_black</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>If true black will be used for labels and co., else a dark grey.</p> </li> <li> <code>latex</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>If true LaTeX font will be used.</p> </li> <li> <code>sf</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Use sans-serif font for text and latex math environment.</p> </li> </ul> Source code in <code>src/prettypyplot/style.py</code> <pre><code>def update_style(  # noqa: C901\n    interactive=None,\n    colors=None,\n    cmap=None,\n    ncs=None,\n    figsize=None,\n    figratio=None,\n    mode=None,\n    style=None,\n    ipython=None,\n    true_black=None,\n    latex=None,\n    sf=None,\n):\n    \"\"\"Update alternative matplotlib style.\n\n    This function updates specified parameters of `use_style` without changing\n    other.\n\n    Parameters\n    ----------\n    interactive : bool, optional\n        Set interactive mode.\n    colors : string, optional\n        Set the default color cycler from continuous or discrete maps. Use any\n        of matplotlibs defaults or specified in the colors submodule.\n    cmap : string, optional\n        Set the default colormap.\n    ncs : int, optional\n        Number of colors if continuous cmap is selected.\n    figsize : int or int tuple, optional\n        Give size of default figure in inches, either as tuple (x, y) or a\n        single float for the x-axis. The y-axis will be determined by figratio.\n    figratio : str or float, optional\n        Set ratio of figsize x:y to 1:1/'option', where 'option' is one\n        of `['sqrt(2)', 'golden', 'sqrt(3)']` or any number. Golden stands for\n        the golden ratio (1.618). This option is ignored if figsize is used\n        with tuple.\n    mode : str, optional\n        One of the following modes:\n        `'default'`: use matplotlib defaults\n        `'beamer'`: extra large fontsize\n        `'print'`: default sizes\n        `'poster'`: for Din A0 posters\n    style : str, optional\n        One of the following styles:\n        `'default'`: enables grid and upper and right spines\n        `'minimal'`: removes all unneeded lines\n        `'none'`: no changes to style\n    ipython : bool, optional\n        Deactivate high-res in jpg/png for compatibility with IPyhton, e.g.\n        jupyter notebook/lab.\n    true_black : bool, optional\n        If true black will be used for labels and co., else a dark grey.\n    latex : bool, optional\n        If true LaTeX font will be used.\n    sf : bool, optional\n        Use sans-serif font for text and latex math environment.\n\n    \"\"\"\n    # set selected mode and style\n    if style is not None:\n        if isinstance(style, Style):\n            pass\n        elif isinstance(style, str) and style.upper() in Style.keys_list():\n            style = Style[style.upper()]\n        else:\n            raise ValueError(\n                'Style \"{st}\" is not supported, use one of {sts}.'.format(\n                    st=style,\n                    sts=Style.keys_list(),\n                ),\n            )\n        _pplt.STYLE = style\n\n    if mode is not None:\n        if isinstance(mode, Mode):\n            pass\n        elif isinstance(mode, str) and mode.upper() in Mode.keys_list():\n            mode = Mode[mode.upper()]\n        else:\n            raise ValueError(\n                'Mode \"{mode}\" is not supported, use one of {modes}.'.format(\n                    mode=mode,\n                    modes=Mode.keys_list(),\n                ),\n            )\n\n        _pplt.MODE = mode\n\n    # set style variables in dictionary\n    for key, val in (\n        ('interactive', interactive),\n        ('colors', colors),\n        ('cmap', cmap),\n        ('ncs', ncs),\n        ('figsize', figsize),\n        ('figratio', figratio),\n        ('ipython', ipython),\n        ('true_black', true_black),\n        ('latex', latex),\n        ('sf', sf),\n    ):\n        if val is not None:\n            _pplt.STYLE_DICT[key] = val\n\n    if _pplt.STYLE is Style.NONE:\n        _reset_style()\n    else:\n        # load static rcParams\n        _apply_style('stylelib/default.mplstyle')\n        if _pplt.STYLE is Style.MINIMAL:\n            _apply_style('stylelib/minimal.mplstyle')\n\n        # set color cycle and cmap\n        _set_rc_colors(\n            colors=colors,\n            cmap=cmap,\n            ncs=ncs,\n            true_black=true_black,\n        )\n\n        # set figsize\n        if figsize is not None:\n            _set_rc_figsize(figratio=figratio, figsize=figsize)\n\n        # increase dpi if not in iypthon\n        _set_rc_dpi(ipython)\n\n        # set interactive mode\n        _set_ineractive_mode(interactive=interactive)\n\n        # setup LaTeX font if latex is available\n        # plt.style.use can not be used.\n        if latex and shutil.which('latex'):\n            _apply_style('stylelib/latex.mplstyle')\n\n        if sf:\n            _set_rc_sansserif()\n\n    if mode is not None:\n        # change widths and fontsize depending on MODE\n        _set_rc_widths(mode)\n</code></pre>"},{"location":"reference/style/#prettypyplot.style.use_style","title":"<code>use_style(interactive=None, colors='pastel5', cmap='macaw', ncs=10, figsize=(3,), figratio='golden', mode=_pplt.MODE, style=_pplt.STYLE, ipython=False, true_black=False, latex=True, sf=False)</code>","text":"<p>Define alternative matplotlib style.</p> <p>This function restores first the matplolib default values and finally changes depicted values to achieve a more appealing appearence. It additionally loads pplts colormaps and colors in matplolib.</p> <p>See update_style for parameters.</p> Source code in <code>src/prettypyplot/style.py</code> <pre><code>@copy_doc_params(update_style)\ndef use_style(\n    interactive=None,\n    colors='pastel5',\n    cmap='macaw',\n    ncs=10,\n    figsize=(3,),\n    figratio='golden',\n    mode=_pplt.MODE,\n    style=_pplt.STYLE,\n    ipython=False,\n    true_black=False,\n    latex=True,\n    sf=False,\n):\n    \"\"\"Define alternative matplotlib style.\n\n    This function restores first the matplolib default values and finally\n    changes depicted values to achieve a more appealing appearence.\n    It additionally loads pplts colormaps and colors in matplolib.\n\n    See [update_style][prettypyplot.update_style] for parameters.\n\n    \"\"\"\n    # restore matplotlib defaults\n    _reset_style()\n\n    # register own continuous and discrete cmaps\n    pclr.load_cmaps()\n\n    # update style\n    update_style(\n        interactive=interactive,\n        colors=colors,\n        cmap=cmap,\n        ncs=ncs,\n        figsize=figsize,\n        figratio=figratio,\n        mode=mode,\n        style=style,\n        ipython=ipython,\n        true_black=true_black,\n        latex=latex,\n        sf=sf,\n    )\n\n    # register used colors\n    pclr.load_colors()\n</code></pre>"},{"location":"reference/subplots/","title":"subplots","text":"<p>Wrapper for matplotlib functions for subplots.</p>"},{"location":"reference/subplots/#prettypyplot.subplots.hide_empty_axes","title":"<code>hide_empty_axes(axs=None)</code>","text":"<p>Hide empty axes.</p> <p>Loop over all axes and hide empty ones.</p> <p>Parameters:</p> <ul> <li> <code>axs</code>               (<code>mpl.axes.Axes or list of</code>, default:                   <code>None</code> )           \u2013            <p>Specify matplotlib.axes.Axes to check for empty state. Default use all of current figure.</p> </li> </ul> Source code in <code>src/prettypyplot/subplots.py</code> <pre><code>def hide_empty_axes(axs=None):\n    \"\"\"Hide empty axes.\n\n    Loop over all axes and hide empty ones.\n\n    Parameters\n    ----------\n    axs : mpl.axes.Axes or list of\n        Specify [matplotlib.axes.Axes][] to check for empty state. Default use\n        all of current figure.\n\n    \"\"\"\n    # check for single axes\n    axs = tools.get_axes(axs)\n\n    # loop over all axes and hide empty ones\n    for ax in axs:\n        if _is_empty_axes(ax):\n            ax.axis('off')\n\n    # in case of shared axes, activate outer tick labels\n    _activate_outer_ticks(axs)\n</code></pre>"},{"location":"reference/subplots/#prettypyplot.subplots.label_outer","title":"<code>label_outer(axs=None)</code>","text":"<p>Only show outer labels and tick labels.</p> <p>This checks for outest visible axes only. Works only with single Gridspec.</p> <p>Parameters:</p> <ul> <li> <code>axs</code>               (<code>mpl.axes.AxesSubplot or list of</code>, default:                   <code>None</code> )           \u2013            <p>Specify matplotlib.axes.Axes to check for labeling only outer. Default use all of current figure.</p> </li> </ul> Source code in <code>src/prettypyplot/subplots.py</code> <pre><code>def label_outer(axs=None):\n    \"\"\"Only show outer labels and tick labels.\n\n    This checks for outest visible axes only. Works only with single Gridspec.\n\n    Parameters\n    ----------\n    axs : mpl.axes.AxesSubplot or list of\n        Specify [matplotlib.axes.Axes][] to check for labeling only outer.\n        Default use all of current figure.\n\n    \"\"\"\n    # check for single axes\n    if axs is not None:\n        axs = tools.get_axes(axs)\n        if not all((_is_subplot_axes(arg) for arg in axs)):\n            raise TypeError(\n                'axs needs to be of type matplotlib.axes.AxesSuplot.',\n            )\n    else:\n        axs = [ax for ax in plt.gcf().get_axes() if _is_subplot_axes(ax)]\n\n    for ax in axs:\n        ss = ax.get_subplotspec()\n        if hasattr(ss, 'is_last_row'):  # pragma: no cover # noqa: WPS421\n            # for mpl &gt;= 3.4\n            lastrow = ss.is_last_row()\n            firstcol = ss.is_first_col()\n        elif hasattr(ax, 'is_last_row'):  # pragma: no cover # noqa: WPS421\n            lastrow = ax.is_last_row()\n            firstcol = ax.is_first_col()\n        else:\n            raise TypeError(f'{ax!r} is not a valid axes.')\n\n        # check if axes below, left is hidden\n        left_empty, bottom_empty = _is_outer_hidden(axs, ax)\n        _label_outer(ax, lastrow or bottom_empty, firstcol or left_empty)\n</code></pre>"},{"location":"reference/subplots/#prettypyplot.subplots.subplot_labels","title":"<code>subplot_labels(*, fig=None, xlabel=None, ylabel=None)</code>","text":"<p>Add global labels for subplots.</p> <p>This method adds shared x- and y-labels for a grid of subplots. These can be created by, e.g. <code>fig, axs = plt.subplots(...)</code>.</p> <p>Parameters:</p> <ul> <li> <code>fig</code>               (<code>matplotlib figure</code>, default:                   <code>None</code> )           \u2013            <p>If <code>None</code> the current figure will be used instead.</p> </li> <li> <code>xlabel</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>String of x label.</p> </li> <li> <code>ylabel</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>String of y label.</p> </li> </ul> Source code in <code>src/prettypyplot/subplots.py</code> <pre><code>def subplot_labels(*, fig=None, xlabel=None, ylabel=None):\n    \"\"\"Add global labels for subplots.\n\n    This method adds shared x- and y-labels for a grid of subplots. These can\n    be created by, e.g. `fig, axs = plt.subplots(...)`.\n\n    Parameters\n    ----------\n    fig : matplotlib figure, optional\n        If `None` the current figure will be used instead.\n    xlabel : str, optional\n        String of x label.\n    ylabel : str, optional\n        String of y label.\n\n    \"\"\"\n    # if no label passed, nothing to do\n    if xlabel is None and ylabel is None:\n        return\n\n    # get active axes to restore it later on\n    ca = plt.gca()\n\n    if fig is None:\n        fig = plt.gcf()\n\n    _subplot_labels(fig, xlabel, ylabel)\n\n    # reset current axes\n    plt.sca(ca)\n</code></pre>"},{"location":"reference/texts/","title":"texts","text":"<p>Helper functions for plotting text.</p>"},{"location":"reference/texts/#prettypyplot.texts.text","title":"<code>text(x, y, s, *, contour=None, ax=None, **kwargs)</code>","text":"<p>Generate text object at (x,y).</p> <p>Wrapper around pyplot.text. The default alignment is changed to centered.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>scalars</code>)           \u2013            <p>The position to place the text. By default, this is in data coordinates. The coordinate system can be changed using the transform parameter.</p> </li> <li> <code>y</code>               (<code>scalars</code>)           \u2013            <p>The position to place the text. By default, this is in data coordinates. The coordinate system can be changed using the transform parameter.</p> </li> <li> <code>s</code>               (<code>str</code>)           \u2013            <p>The text.</p> </li> <li> <code>contour</code>               (<code>bool or tuple(scalar, color)</code>, default:                   <code>None</code> )           \u2013            <p>Add a contour to the text. Either use a boolean for default values, or give a tuple with linewidth and linecolor.</p> </li> <li> <code>ax</code>               (<code>matplotlib axes</code>, default:                   <code>None</code> )           \u2013            <p>Matplotlib axes to plot in.</p> </li> <li> <code>kwargs</code>           \u2013            <p>Text properties of matplotlib.pyplot.text</p> </li> </ul> Source code in <code>src/prettypyplot/texts.py</code> <pre><code>def text(x, y, s, *, contour=None, ax=None, **kwargs):\n    \"\"\"Generate text object at (x,y).\n\n    Wrapper around pyplot.text. The default alignment is changed to centered.\n\n    Parameters\n    ----------\n    x, y : scalars\n        The position to place the text. By default, this is in data\n        coordinates. The coordinate system can be changed using the\n        *transform* parameter.\n    s : str\n        The text.\n    contour : bool or tuple(scalar, color)\n        Add a contour to the text. Either use a boolean for default values,\n        or give a tuple with linewidth and linecolor.\n    ax : matplotlib axes\n        Matplotlib axes to plot in.\n    kwargs\n        Text properties of [matplotlib.pyplot.text][]\n\n    \"\"\"\n    # parse axes\n    ax = tools.gca(ax)\n\n    # change default alignment\n    if 'va' not in kwargs and 'verticalalignment' not in kwargs:\n        kwargs['va'] = 'center'\n    if 'ha' not in kwargs and 'horizontalalignment' not in kwargs:\n        kwargs['ha'] = 'center'\n\n    # plot text\n    txt = ax.text(x=x, y=y, s=s, **kwargs)\n\n    # generate contour\n    if contour is not None:\n        contour_kwargs = _parse_contour(contour)\n        if contour_kwargs is not None:\n            add_contour(txt, **contour_kwargs)\n\n    return txt\n</code></pre>"},{"location":"reference/texts/#prettypyplot.texts.figtext","title":"<code>figtext(x, y, s, *, contour=None, **kwargs)</code>","text":"<p>Generate text object at figure position (x,y).</p> <p>Wrapper around pyplot.figtext. The default alignment is changed to centered.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>scalars</code>)           \u2013            <p>The position to place the text. By default, this is in data coordinates. The coordinate system can be changed using the <code>transform</code> parameter.</p> </li> <li> <code>y</code>               (<code>scalars</code>)           \u2013            <p>The position to place the text. By default, this is in data coordinates. The coordinate system can be changed using the <code>transform</code> parameter.</p> </li> <li> <code>s</code>               (<code>str</code>)           \u2013            <p>The text.</p> </li> <li> <code>contour</code>               (<code>bool or tuple(scalar, color)</code>, default:                   <code>None</code> )           \u2013            <p>Add a contour to the text. Either use a boolean for default values, or give a tuple with linewidth and linecolor.</p> </li> <li> <code>ax</code>               (<code>matplotlib axes</code>)           \u2013            <p>Matplotlib axes to plot in.</p> </li> <li> <code>kwargs</code>           \u2013            <p>Text properties of matplotlib.pyplot.figtext</p> </li> </ul> Source code in <code>src/prettypyplot/texts.py</code> <pre><code>def figtext(x, y, s, *, contour=None, **kwargs):\n    \"\"\"Generate text object at figure position (x,y).\n\n    Wrapper around pyplot.figtext. The default alignment is changed to\n    centered.\n\n    Parameters\n    ----------\n    x, y : scalars\n        The position to place the text. By default, this is in data\n        coordinates. The coordinate system can be changed using the\n        `transform` parameter.\n    s : str\n        The text.\n    contour : bool or tuple(scalar, color)\n        Add a contour to the text. Either use a boolean for default values,\n        or give a tuple with linewidth and linecolor.\n    ax : matplotlib axes\n        Matplotlib axes to plot in.\n    kwargs\n        Text properties of [matplotlib.pyplot.figtext][]\n\n    \"\"\"\n    # change default alignment\n    if 'va' not in kwargs and 'verticalalignment' not in kwargs:\n        kwargs['va'] = 'center'\n    if 'ha' not in kwargs and 'horizontalalignment' not in kwargs:\n        kwargs['ha'] = 'center'\n\n    # plot text\n    txt = plt.figtext(x=x, y=y, s=s, **kwargs)\n\n    # generate contour\n    if contour is not None:\n        contour_kwargs = _parse_contour(contour)\n        if contour_kwargs is not None:\n            add_contour(txt, **contour_kwargs)\n\n    return txt\n</code></pre>"},{"location":"reference/texts/#prettypyplot.texts.add_contour","title":"<code>add_contour(txt, contourwidth, contourcolor='w')</code>","text":"<p>Draw contour around txt.</p> <p>Parameters:</p> <ul> <li> <code>txt</code>               (<code>mpl Text</code>)           \u2013            <p>Instance of matplotlib.text.Text. Can be obtained by, e.g., <code>txt = plt.text()</code> or <code>txt = plt.figtext()</code>.</p> </li> <li> <code>contourwidth</code>               (<code>scalar</code>)           \u2013            <p>Width of contour.</p> </li> <li> <code>contourcolor</code>               (<code>RGB color or matplotlib predefined color</code>, default:                   <code>'w'</code> )           \u2013            <p>Color of contour, default is white.</p> </li> </ul> Source code in <code>src/prettypyplot/texts.py</code> <pre><code>def add_contour(txt, contourwidth, contourcolor='w'):\n    r\"\"\"Draw contour around txt.\n\n    Parameters\n    ----------\n    txt : mpl Text\n        Instance of [matplotlib.text.Text][]. Can be obtained by, e.g.,\n        `txt = plt.text()` or `txt = plt.figtext()`.\n    contourwidth : scalar\n        Width of contour.\n    contourcolor : RGB color or matplotlib predefined color, optional\n        Color of contour, default is white.\n\n    \"\"\"\n    # check if is text object\n    if not isinstance(txt, mpl.text.Text):\n        raise TypeError(\n            'txt needs to be \"matplotlib.text.Text\", but ' + 'is {t}'.format(t=txt),\n        )\n    # check if number\n    if not tools.is_number(contourwidth):\n        raise TypeError(\n            'contourwidth={w} needs to be a number.'.format(w=contourwidth),\n        )\n\n    # check if color\n    if not clr.is_color_like(contourcolor):\n        raise TypeError(\n            'contourcolor={c} can not be '.format(c=contourcolor)\n            + 'interpreted as color.',\n        )\n\n    path_args = [\n        path_effects.withStroke(\n            linewidth=contourwidth,\n            foreground=contourcolor,\n        )\n    ]\n    txt.set_path_effects(path_args)\n</code></pre>"},{"location":"reference/tools/","title":"tools","text":"<p>This module contains utility functions used in multiple submodules.</p>"},{"location":"reference/tools/#prettypyplot.tools.is_number","title":"<code>is_number(number, *, dtype=float)</code>","text":"<p>Check if argument can be interpreated as number.</p> <p>Parameters:</p> <ul> <li> <code>number</code>               (<code>(string, float, int)</code>)           \u2013            <p>Variable to be check if it can be casted to float.</p> </li> <li> <code>dtype</code>               (<code>dtype</code>, default:                   <code>float</code> )           \u2013            <p>Check for different dtypes, so if is float or if it is int.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>is_number</code> (              <code>bool</code> )          \u2013            <p>Return if argument can be casted to float.</p> </li> </ul> Source code in <code>src/prettypyplot/tools.py</code> <pre><code>def is_number(number, *, dtype=float):\n    \"\"\"Check if argument can be interpreated as number.\n\n    Parameters\n    ----------\n    number : string, float, int\n        Variable to be check if it can be casted to float.\n    dtype : dtype, optional\n        Check for different dtypes, so if is float or if it is int.\n\n    Returns\n    -------\n    is_number : bool\n        Return if argument can be casted to float.\n\n    \"\"\"\n    try:\n        float(number)\n    except (ValueError, TypeError):\n        return False\n    return float(number) == dtype(number)\n</code></pre>"},{"location":"reference/tools/#prettypyplot.tools.invert_sign","title":"<code>invert_sign(num)</code>","text":"<p>Change sign of number or add/remove leading sign of str.</p> Source code in <code>src/prettypyplot/tools.py</code> <pre><code>def invert_sign(num):\n    \"\"\"Change sign of number or add/remove leading sign of str.\"\"\"\n    if isinstance(num, (float, int)):\n        return -1 * num\n    elif isinstance(num, str):\n        if num.startswith('-'):\n            return num[1:]\n        return '-{0}'.format(num)\n    raise ValueError(\n        'Num needs to be numeric value or string, not ' + '{0}.'.format(num),\n    )\n</code></pre>"},{"location":"reference/tools/#prettypyplot.tools.parse_axes","title":"<code>parse_axes(*args, ax)</code>","text":"<p>Extract axes from ax, args or returns args and current axes.</p> Source code in <code>src/prettypyplot/tools.py</code> <pre><code>def parse_axes(*args, ax):\n    \"\"\"Extract axes from ax, args or returns args and current axes.\"\"\"\n    axes = [arg for arg in args if isinstance(arg, mpl.axes.Axes)]\n    if axes:\n        if isinstance(ax, mpl.axes.Axes) or len(axes) &gt; 1:\n            raise ValueError('Multiple axes provided')\n        ax = axes[0]\n        args = tuple(arg for arg in args if not isinstance(arg, mpl.axes.Axes))\n    else:\n        ax = gca(ax)\n    return args, ax\n</code></pre>"},{"location":"reference/tools/#prettypyplot.tools.gca","title":"<code>gca(ax)</code>","text":"<p>Return ax if it is axes instance, else the current active axes.</p> Source code in <code>src/prettypyplot/tools.py</code> <pre><code>def gca(ax):\n    \"\"\"Return ax if it is axes instance, else the current active axes.\"\"\"\n    if isinstance(ax, mpl.axes.Axes):\n        return ax\n    return plt.gca()\n</code></pre>"},{"location":"reference/tools/#prettypyplot.tools.get_axes","title":"<code>get_axes(axs)</code>","text":"<p>Return axs if it is all axes instances, else the all current axes.</p> Source code in <code>src/prettypyplot/tools.py</code> <pre><code>def get_axes(axs):\n    \"\"\"Return axs if it is all axes instances, else the all current axes.\"\"\"\n    if axs is None:\n        return plt.gcf().get_axes()\n\n    axs = np.ravel(axs)\n    if not all((isinstance(arg, mpl.axes.Axes) for arg in axs)):\n        raise TypeError(\n            'If `axs` is given, it needs to be of type matplotlib.axes.Axes.'\n            + ' or list of',\n        )\n    return axs\n</code></pre>"},{"location":"reference/tools/#prettypyplot.tools.is_discrete_cmap","title":"<code>is_discrete_cmap(cmap)</code>","text":"<p>Return if cmap is discrete or continuos.</p> Source code in <code>src/prettypyplot/tools.py</code> <pre><code>def is_discrete_cmap(cmap: str) -&gt; bool:\n    \"\"\"Return if cmap is discrete or continuos.\"\"\"\n    return plt.get_cmap(cmap).N &lt; 256\n</code></pre>"}]}