<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>prettypyplot.colors API documentation</title>
<meta name="description" content="Set-up matplotlib environment â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:0.01em .5em;margin:0em 3em 1em 3em}.admonition-title{font-weight:bold;margin-bottom:-1em}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#cfa}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:7em;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="gallery/logo.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>prettypyplot.colors</code></h1>
</header>
<section id="section-intro">
<p>Set-up matplotlib environment.</p>
<p>BSD 3-Clause License
Copyright (c) 2020, Daniel Nagel
All rights reserved.</p>
<p>Author: Daniel Nagel</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Set-up matplotlib environment.

BSD 3-Clause License
Copyright (c) 2020, Daniel Nagel
All rights reserved.

Author: Daniel Nagel

&#34;&#34;&#34;
# ~~~ IMPORT ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import matplotlib.colors as clr
import matplotlib.pyplot as plt
import numpy as np

# import colormaps
from .cmaps._bownair import __bownair
from .cmaps._discrete import (
    __cbf4,
    __cbf5,
    __cbf8,
    __pastel5,
    __pastel6,
    __pastel_autunm,
    __pastel_rainbow,
    __pastel_spring,
    __ufcd,
)
from .cmaps._macaw import __macaw
from .cmaps._turbo import __turbo


# ~~~ FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def load_cmaps():
    &#34;&#34;&#34;
    Load and include custom colormaps to matplotlib.

    Add sequential colormaps &#39;pastel5&#39;, &#39;pastel6&#39;, &#39;cbf4&#39;, &#39;cbf5&#39;, &#39;cbf8&#39;,
    and &#39;ufcd&#39; as an corporate design. Except of &#39;ufcd&#39; all palettes should be
    &#39;color-blind-friendly&#39;.

    Add continuous colormaps macaw, Turbo. The Copyright of
    those are given on top of the data.

    .. see:: `prettypyplot.cmaps`

    &#34;&#34;&#34;
    # register own continuous and discrete cmaps
    for colormap in [__pastel5(), __pastel6(), __cbf4(), __cbf5(), __cbf8(),
                     __pastel_autunm(), __pastel_rainbow(), __pastel_spring(),
                     __ufcd(), __turbo(), __macaw(), __bownair()]:
        # add cmap
        if colormap.name not in plt.cm.cmap_d:
            plt.register_cmap(cmap=colormap)
        # add reversed cmap
        if colormap.reversed().name not in plt.cm.cmap_d:
            plt.register_cmap(cmap=colormap.reversed())


def load_colors():
    &#34;&#34;&#34;
    Load and include custom colors to matplotlib.

    Add colors of &#39;pastel5&#39; which can be accessed via &#39;pplt:blue&#39;, &#39;pplt:red&#39;,
    &#39;pplt:green&#39;, &#39;pplt:orange&#39;, &#39;pplt:lightblue&#39;. Further, the current colors
    will be added &#39;pplt:axes&#39;, &#39;pplt:text&#39;, &#39;pplt:grid&#39;.

    .. see:: `prettypyplot.cmaps`

    &#34;&#34;&#34;
    # register own colors
    pplt_colors = {
        &#39;pplt:blue&#39;: __pastel5().colors[0],
        &#39;pplt:red&#39;: __pastel5().colors[1],
        &#39;pplt:green&#39;: __pastel5().colors[2],
        &#39;pplt:orange&#39;: __pastel5().colors[3],
        &#39;pplt:lightblue&#39;: __pastel5().colors[4],
        &#39;pplt:axes&#39;: plt.rcParams[&#39;axes.edgecolor&#39;],
        &#39;pplt:text&#39;: plt.rcParams[&#39;text.color&#39;],
        &#39;pplt:grid&#39;: plt.rcParams[&#39;grid.color&#39;],
    }
    clr._colors_full_map.update(pplt_colors)


def categorical_cmap(nc,
                     nsc,
                     cmap=None,
                     return_colors=False):
    &#34;&#34;&#34;
    Generate categorical colors of given cmap.

    Exract from a predefined colormap colors and generate for each the desired
    number of shades.

    Parameters
    ----------
    nc : int
        Number of colors

    nsc : int
        Number of shades per colors

    cmap : mpl colormap, optional
        Matplotlib colormap to take colors from. The default is the active
        color cycle.

    return_colors : bool, optional
        Return an array of rgb colors. Each color together with its shades are
        in an own row.

    Returns
    -------
    scolors : mpl colormap
        Return discrete colormap. If return_colors, a 2d representation will
        be returned instead.

    &#34;&#34;&#34;
    # check correct data type
    if int(nc) != nc or int(nsc) != nsc:
        raise TypeError(&#39;nc and nsc need to be an integer.&#39;)
    nc, nsc = int(nc), int(nsc)

    # get cmap
    if cmap is not None:
        cmap = plt.get_cmap(cmap)
    else:
        cmap = clr.ListedColormap(plt.rcParams[&#39;axes.prop_cycle&#39;]
                                  .by_key()[&#39;color&#39;])
    if nc &gt; cmap.N:
        raise ValueError(&#39;Too many categories for colormap.&#39;)

    # extract colors from cmap
    if type(cmap) == clr.LinearSegmentedColormap:
        colors = cmap(np.linspace(0, 1, nc))
    elif type(cmap) == clr.ListedColormap:
        colors = cmap(np.arange(nc, dtype=int))

    # get shades of colors
    scolors = np.empty((nc, nsc, 3))
    for i, c in enumerate(colors):
        scolors[i] = categorical_color(nsc, c)

    # return colors
    if return_colors:
        return scolors
    else:
        return clr.ListedColormap(np.concatenate(scolors))


def categorical_color(nsc, color, return_hex=False):
    &#34;&#34;&#34;
    Generate categorical shades of given colors.

    Generate for each provided color the number of specified shades. The shaded
    colors are interpolated linearly in HSV colorspace. This function is based
    on following post: https://stackoverflow.com/a/47232942

    Parameters
    ----------
    nsc : int
        Number of shades per color.

    color : RGB color or matplotlib predefined color
        Color used for generating shades.

    return_hex : bool, optional
        Return colors in hex format instead of rgb.

    Returns
    -------
    colors_rgb : list of RGB colors
        A list containing shaded colors. Where the list is sorted from the
        original color at the beginning to the most shaded one at the end.
        The default color encoding is rgb and hex if specified.

    &#34;&#34;&#34;
    # check correct data type
    if not clr.is_color_like(color):
        raise TypeError(&#39;{c} can not be interpreted as color.&#39;.format(c=color))
    if int(nsc) != nsc:
        raise TypeError(&#39;nsc need to be an integer.&#39;)
    nsc = int(nsc)

    # genrate shades of colors
    color_hsv = clr.rgb_to_hsv(clr.to_rgb(color))
    colors_hsv = np.tile(color_hsv, nsc).reshape(nsc, 3)
    colors_hsv[:, 1] = np.linspace(color_hsv[1], 0.25, nsc)
    colors_hsv[:, 2] = np.linspace(color_hsv[2], 1, nsc)
    colors_rgb = clr.hsv_to_rgb(colors_hsv)

    if return_hex:
        return [clr.to_hex(c) for c in colors_rgb]
    else:
        return colors_rgb


def text_color(bgcolor, colors=(&#39;#000000&#39;, &#39;#ffffff&#39;)):
    &#34;&#34;&#34;Select textcolor with maximal contrast on background.

    All parameters needs to be colors accepted by matplotlib, see
    [matplotlib.colors](https://matplotlib.org/api/colors_api.html).
    The formulas are taken from W3C [WCAG 2.1](https://www.w3.org/TR/WCAG21)
    (Web Content Accessibility Guidelines).

    Parameters
    ----------
    bgcolor : matplotlib color
        Background color to which the contrast is maximized.

    colors : list of matplotlib colors, optional
        Selection of textcolors to choose from.

    Returns
    -------
    color : matplotlib color
        Color of colors which has the highest contrast on the given bgcolor.

    &#34;&#34;&#34;
    def channel_transf(channel):
        &#34;&#34;&#34;Transform channel for luminance calculation.&#34;&#34;&#34;
        if channel &lt; 0.03928:
            return channel / 12.92
        else:
            return ((channel + 0.055) / 1.055)**2.4

    def relative_luminance(color):
        &#34;&#34;&#34;Calculate luminance from rgb color, each channel [0, 1].&#34;&#34;&#34;
        r, g, b = [channel_transf(c) for c in color]
        return 0.2126 * r + 0.7152 * g + 0.0722 * b

    def contrast(L1, L2):
        &#34;&#34;&#34;L1 and L2 should be luminances [0, 1].&#34;&#34;&#34;
        if L1 &lt; L2:
            L1, L2 = L2, L1
        return (L1 + 0.05) / (L2 + 0.05)

    # check input by casting to matplotlib colors
    bgcolor = clr.to_rgb(bgcolor)
    colors_rgb = [clr.to_rgb(c) for c in colors]

    # calculate the (luminances)
    bgL = relative_luminance(bgcolor)
    Ls = [relative_luminance(c) for c in colors_rgb]

    # calculate contrast between bgcolor and all colors
    C = [contrast(bgL, L) for L in Ls]

    # return color corresponding to greatest contrast
    idx = C.index(max(C))
    return colors[idx]


# ~~~ COLORS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# gray tones
black_grays = {&#39;dark&#39;: &#39;#000000&#39;, &#39;light&#39;: &#39;#dddfe5&#39;}
default_grays = {&#39;dark&#39;: &#39;#4d4f53&#39;, &#39;light&#39;: &#39;#dddfe5&#39;}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="prettypyplot.colors.categorical_cmap"><code class="name flex">
<span>def <span class="ident">categorical_cmap</span></span>(<span>nc, nsc, cmap=None, return_colors=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate categorical colors of given cmap.</p>
<p>Exract from a predefined colormap colors and generate for each the desired
number of shades.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nc</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of colors</dd>
<dt><strong><code>nsc</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of shades per colors</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>mpl colormap</code>, optional</dt>
<dd>Matplotlib colormap to take colors from. The default is the active
color cycle.</dd>
<dt><strong><code>return_colors</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Return an array of rgb colors. Each color together with its shades are
in an own row.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>scolors</code></strong> :&ensp;<code>mpl colormap</code></dt>
<dd>Return discrete colormap. If return_colors, a 2d representation will
be returned instead.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def categorical_cmap(nc,
                     nsc,
                     cmap=None,
                     return_colors=False):
    &#34;&#34;&#34;
    Generate categorical colors of given cmap.

    Exract from a predefined colormap colors and generate for each the desired
    number of shades.

    Parameters
    ----------
    nc : int
        Number of colors

    nsc : int
        Number of shades per colors

    cmap : mpl colormap, optional
        Matplotlib colormap to take colors from. The default is the active
        color cycle.

    return_colors : bool, optional
        Return an array of rgb colors. Each color together with its shades are
        in an own row.

    Returns
    -------
    scolors : mpl colormap
        Return discrete colormap. If return_colors, a 2d representation will
        be returned instead.

    &#34;&#34;&#34;
    # check correct data type
    if int(nc) != nc or int(nsc) != nsc:
        raise TypeError(&#39;nc and nsc need to be an integer.&#39;)
    nc, nsc = int(nc), int(nsc)

    # get cmap
    if cmap is not None:
        cmap = plt.get_cmap(cmap)
    else:
        cmap = clr.ListedColormap(plt.rcParams[&#39;axes.prop_cycle&#39;]
                                  .by_key()[&#39;color&#39;])
    if nc &gt; cmap.N:
        raise ValueError(&#39;Too many categories for colormap.&#39;)

    # extract colors from cmap
    if type(cmap) == clr.LinearSegmentedColormap:
        colors = cmap(np.linspace(0, 1, nc))
    elif type(cmap) == clr.ListedColormap:
        colors = cmap(np.arange(nc, dtype=int))

    # get shades of colors
    scolors = np.empty((nc, nsc, 3))
    for i, c in enumerate(colors):
        scolors[i] = categorical_color(nsc, c)

    # return colors
    if return_colors:
        return scolors
    else:
        return clr.ListedColormap(np.concatenate(scolors))</code></pre>
</details>
</dd>
<dt id="prettypyplot.colors.categorical_color"><code class="name flex">
<span>def <span class="ident">categorical_color</span></span>(<span>nsc, color, return_hex=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate categorical shades of given colors.</p>
<p>Generate for each provided color the number of specified shades. The shaded
colors are interpolated linearly in HSV colorspace. This function is based
on following post: <a href="https://stackoverflow.com/a/47232942">https://stackoverflow.com/a/47232942</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nsc</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of shades per color.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>RGB color</code> or <code>matplotlib predefined color</code></dt>
<dd>Color used for generating shades.</dd>
<dt><strong><code>return_hex</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Return colors in hex format instead of rgb.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>colors_rgb</code></strong> :&ensp;<code>list</code> of <code>RGB colors</code></dt>
<dd>A list containing shaded colors. Where the list is sorted from the
original color at the beginning to the most shaded one at the end.
The default color encoding is rgb and hex if specified.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def categorical_color(nsc, color, return_hex=False):
    &#34;&#34;&#34;
    Generate categorical shades of given colors.

    Generate for each provided color the number of specified shades. The shaded
    colors are interpolated linearly in HSV colorspace. This function is based
    on following post: https://stackoverflow.com/a/47232942

    Parameters
    ----------
    nsc : int
        Number of shades per color.

    color : RGB color or matplotlib predefined color
        Color used for generating shades.

    return_hex : bool, optional
        Return colors in hex format instead of rgb.

    Returns
    -------
    colors_rgb : list of RGB colors
        A list containing shaded colors. Where the list is sorted from the
        original color at the beginning to the most shaded one at the end.
        The default color encoding is rgb and hex if specified.

    &#34;&#34;&#34;
    # check correct data type
    if not clr.is_color_like(color):
        raise TypeError(&#39;{c} can not be interpreted as color.&#39;.format(c=color))
    if int(nsc) != nsc:
        raise TypeError(&#39;nsc need to be an integer.&#39;)
    nsc = int(nsc)

    # genrate shades of colors
    color_hsv = clr.rgb_to_hsv(clr.to_rgb(color))
    colors_hsv = np.tile(color_hsv, nsc).reshape(nsc, 3)
    colors_hsv[:, 1] = np.linspace(color_hsv[1], 0.25, nsc)
    colors_hsv[:, 2] = np.linspace(color_hsv[2], 1, nsc)
    colors_rgb = clr.hsv_to_rgb(colors_hsv)

    if return_hex:
        return [clr.to_hex(c) for c in colors_rgb]
    else:
        return colors_rgb</code></pre>
</details>
</dd>
<dt id="prettypyplot.colors.load_cmaps"><code class="name flex">
<span>def <span class="ident">load_cmaps</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Load and include custom colormaps to matplotlib.</p>
<p>Add sequential colormaps 'pastel5', 'pastel6', 'cbf4', 'cbf5', 'cbf8',
and 'ufcd' as an corporate design. Except of 'ufcd' all palettes should be
'color-blind-friendly'.</p>
<p>Add continuous colormaps macaw, Turbo. The Copyright of
those are given on top of the data.</p>
<div class="admonition see">
<p class="admonition-title">See:&ensp;<code><a title="prettypyplot.cmaps" href="cmaps/index.html">prettypyplot.cmaps</a></code></p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_cmaps():
    &#34;&#34;&#34;
    Load and include custom colormaps to matplotlib.

    Add sequential colormaps &#39;pastel5&#39;, &#39;pastel6&#39;, &#39;cbf4&#39;, &#39;cbf5&#39;, &#39;cbf8&#39;,
    and &#39;ufcd&#39; as an corporate design. Except of &#39;ufcd&#39; all palettes should be
    &#39;color-blind-friendly&#39;.

    Add continuous colormaps macaw, Turbo. The Copyright of
    those are given on top of the data.

    .. see:: `prettypyplot.cmaps`

    &#34;&#34;&#34;
    # register own continuous and discrete cmaps
    for colormap in [__pastel5(), __pastel6(), __cbf4(), __cbf5(), __cbf8(),
                     __pastel_autunm(), __pastel_rainbow(), __pastel_spring(),
                     __ufcd(), __turbo(), __macaw(), __bownair()]:
        # add cmap
        if colormap.name not in plt.cm.cmap_d:
            plt.register_cmap(cmap=colormap)
        # add reversed cmap
        if colormap.reversed().name not in plt.cm.cmap_d:
            plt.register_cmap(cmap=colormap.reversed())</code></pre>
</details>
</dd>
<dt id="prettypyplot.colors.load_colors"><code class="name flex">
<span>def <span class="ident">load_colors</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Load and include custom colors to matplotlib.</p>
<p>Add colors of 'pastel5' which can be accessed via 'pplt:blue', 'pplt:red',
'pplt:green', 'pplt:orange', 'pplt:lightblue'. Further, the current colors
will be added 'pplt:axes', 'pplt:text', 'pplt:grid'.</p>
<div class="admonition see">
<p class="admonition-title">See:&ensp;<code><a title="prettypyplot.cmaps" href="cmaps/index.html">prettypyplot.cmaps</a></code></p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_colors():
    &#34;&#34;&#34;
    Load and include custom colors to matplotlib.

    Add colors of &#39;pastel5&#39; which can be accessed via &#39;pplt:blue&#39;, &#39;pplt:red&#39;,
    &#39;pplt:green&#39;, &#39;pplt:orange&#39;, &#39;pplt:lightblue&#39;. Further, the current colors
    will be added &#39;pplt:axes&#39;, &#39;pplt:text&#39;, &#39;pplt:grid&#39;.

    .. see:: `prettypyplot.cmaps`

    &#34;&#34;&#34;
    # register own colors
    pplt_colors = {
        &#39;pplt:blue&#39;: __pastel5().colors[0],
        &#39;pplt:red&#39;: __pastel5().colors[1],
        &#39;pplt:green&#39;: __pastel5().colors[2],
        &#39;pplt:orange&#39;: __pastel5().colors[3],
        &#39;pplt:lightblue&#39;: __pastel5().colors[4],
        &#39;pplt:axes&#39;: plt.rcParams[&#39;axes.edgecolor&#39;],
        &#39;pplt:text&#39;: plt.rcParams[&#39;text.color&#39;],
        &#39;pplt:grid&#39;: plt.rcParams[&#39;grid.color&#39;],
    }
    clr._colors_full_map.update(pplt_colors)</code></pre>
</details>
</dd>
<dt id="prettypyplot.colors.text_color"><code class="name flex">
<span>def <span class="ident">text_color</span></span>(<span>bgcolor, colors=('#000000', '#ffffff'))</span>
</code></dt>
<dd>
<div class="desc"><p>Select textcolor with maximal contrast on background.</p>
<p>All parameters needs to be colors accepted by matplotlib, see
<a href="https://matplotlib.org/api/colors_api.html">matplotlib.colors</a>.
The formulas are taken from W3C <a href="https://www.w3.org/TR/WCAG21">WCAG 2.1</a>
(Web Content Accessibility Guidelines).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bgcolor</code></strong> :&ensp;<code>matplotlib color</code></dt>
<dd>Background color to which the contrast is maximized.</dd>
<dt><strong><code>colors</code></strong> :&ensp;<code>list</code> of <code>matplotlib colors</code>, optional</dt>
<dd>Selection of textcolors to choose from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>color</code></strong> :&ensp;<code>matplotlib color</code></dt>
<dd>Color of colors which has the highest contrast on the given bgcolor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def text_color(bgcolor, colors=(&#39;#000000&#39;, &#39;#ffffff&#39;)):
    &#34;&#34;&#34;Select textcolor with maximal contrast on background.

    All parameters needs to be colors accepted by matplotlib, see
    [matplotlib.colors](https://matplotlib.org/api/colors_api.html).
    The formulas are taken from W3C [WCAG 2.1](https://www.w3.org/TR/WCAG21)
    (Web Content Accessibility Guidelines).

    Parameters
    ----------
    bgcolor : matplotlib color
        Background color to which the contrast is maximized.

    colors : list of matplotlib colors, optional
        Selection of textcolors to choose from.

    Returns
    -------
    color : matplotlib color
        Color of colors which has the highest contrast on the given bgcolor.

    &#34;&#34;&#34;
    def channel_transf(channel):
        &#34;&#34;&#34;Transform channel for luminance calculation.&#34;&#34;&#34;
        if channel &lt; 0.03928:
            return channel / 12.92
        else:
            return ((channel + 0.055) / 1.055)**2.4

    def relative_luminance(color):
        &#34;&#34;&#34;Calculate luminance from rgb color, each channel [0, 1].&#34;&#34;&#34;
        r, g, b = [channel_transf(c) for c in color]
        return 0.2126 * r + 0.7152 * g + 0.0722 * b

    def contrast(L1, L2):
        &#34;&#34;&#34;L1 and L2 should be luminances [0, 1].&#34;&#34;&#34;
        if L1 &lt; L2:
            L1, L2 = L2, L1
        return (L1 + 0.05) / (L2 + 0.05)

    # check input by casting to matplotlib colors
    bgcolor = clr.to_rgb(bgcolor)
    colors_rgb = [clr.to_rgb(c) for c in colors]

    # calculate the (luminances)
    bgL = relative_luminance(bgcolor)
    Ls = [relative_luminance(c) for c in colors_rgb]

    # calculate contrast between bgcolor and all colors
    C = [contrast(bgL, L) for L in Ls]

    # return color corresponding to greatest contrast
    idx = C.index(max(C))
    return colors[idx]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="prettypyplot home" href="https://braniii.gitlab.io/prettypyplot">
<img src="gallery/logo.png" alt=""> prettypyplot
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="prettypyplot" href="index.html">prettypyplot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="prettypyplot.colors.categorical_cmap" href="#prettypyplot.colors.categorical_cmap">categorical_cmap</a></code></li>
<li><code><a title="prettypyplot.colors.categorical_color" href="#prettypyplot.colors.categorical_color">categorical_color</a></code></li>
<li><code><a title="prettypyplot.colors.load_cmaps" href="#prettypyplot.colors.load_cmaps">load_cmaps</a></code></li>
<li><code><a title="prettypyplot.colors.load_colors" href="#prettypyplot.colors.load_colors">load_colors</a></code></li>
<li><code><a title="prettypyplot.colors.text_color" href="#prettypyplot.colors.text_color">text_color</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://gitlab.com/braniii/prettypyplot" class="github-corner" aria-label="View source on GitHub">
<svg width="80" height="80" viewBox="0 0 250 250" style="fill:#4d4f53; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
<path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
<path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
</svg>
</a>
<style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>